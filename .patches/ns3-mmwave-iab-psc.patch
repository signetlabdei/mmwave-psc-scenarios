diff -Naru '--exclude=.git' ns3-mmwave-iab/scratch/mmwave-iab-grid.cc iab-psc/scratch/mmwave-iab-grid.cc
--- ns3-mmwave-iab/scratch/mmwave-iab-grid.cc	2019-02-15 18:12:55.035613768 +0100
+++ iab-psc/scratch/mmwave-iab-grid.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,466 +0,0 @@
- /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
- /*
- *   Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
- *   Copyright (c) 2015, NYU WIRELESS, Tandon School of Engineering, New York University
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License version 2 as
- *   published by the Free Software Foundation;
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- *   Author: Marco Miozzo <marco.miozzo@cttc.es>
- *           Nicola Baldo  <nbaldo@cttc.es>
- *
- *   Modified by: Marco Mezzavilla < mezzavilla@nyu.edu>
- *        	 	  Sourjya Dutta <sdutta@nyu.edu>
- *        	 	  Russell Ford <russell.ford@nyu.edu>
- *        		  Menglei Zhang <menglei@nyu.edu>
- */
-
-#include <ns3/buildings-module.h>
-#include "ns3/mmwave-helper.h"
-#include "ns3/lte-module.h"
-#include "ns3/epc-helper.h"
-#include "ns3/core-module.h"
-#include "ns3/network-module.h"
-#include "ns3/ipv4-global-routing-helper.h"
-#include "ns3/internet-module.h"
-#include "ns3/mobility-module.h"
-#include "ns3/applications-module.h"
-#include "ns3/point-to-point-helper.h"
-#include "ns3/config-store.h"
-#include "ns3/mmwave-point-to-point-epc-helper.h"
-//#include "ns3/gtk-config-store.h"
-
-using namespace ns3;
-
-NS_LOG_COMPONENT_DEFINE ("MmWaveIabGrid");
-
-
-void 
-PrintGnuplottableBuildingListToFile (std::string filename)
-{
-  std::ofstream outFile;
-  outFile.open (filename.c_str (), std::ios_base::out | std::ios_base::trunc);
-  if (!outFile.is_open ())
-    {
-      NS_LOG_ERROR ("Can't open file " << filename);
-      return;
-    }
-  uint32_t index = 0;
-  for (BuildingList::Iterator it = BuildingList::Begin (); it != BuildingList::End (); ++it)
-    {
-      ++index;
-      Box box = (*it)->GetBoundaries ();
-      outFile << "set object " << index
-              << " rect from " << box.xMin  << "," << box.yMin
-              << " to "   << box.xMax  << "," << box.yMax
-              //<< " height " << box.zMin << "," << box.zMax
-              << " front fs empty "
-              << std::endl;
-    }
-}
-
-void 
-PrintGnuplottableUeListToFile (std::string filename)
-{
-  std::ofstream outFile;
-  outFile.open (filename.c_str (), std::ios_base::out | std::ios_base::trunc);
-  if (!outFile.is_open ())
-    {
-      NS_LOG_ERROR ("Can't open file " << filename);
-      return;
-    }
-  for (NodeList::Iterator it = NodeList::Begin (); it != NodeList::End (); ++it)
-    {
-      Ptr<Node> node = *it;
-      int nDevs = node->GetNDevices ();
-      for (int j = 0; j < nDevs; j++)
-        {
-          Ptr<LteUeNetDevice> uedev = node->GetDevice (j)->GetObject <LteUeNetDevice> ();
-          Ptr<MmWaveUeNetDevice> mmuedev = node->GetDevice (j)->GetObject <MmWaveUeNetDevice> ();
-          Ptr<McUeNetDevice> mcuedev = node->GetDevice (j)->GetObject <McUeNetDevice> ();
-          if (uedev)
-            {
-              Vector pos = node->GetObject<MobilityModel> ()->GetPosition ();
-              outFile << "set label \"" << uedev->GetImsi ()
-                      << "\" at "<< pos.x << "," << pos.y << " left font \"Helvetica,8\" textcolor rgb \"black\" front point pt 1 ps 0.3 lc rgb \"black\" offset 0,0"
-                      << std::endl;
-            }
-          else if (mmuedev)
-           {
-              Vector pos = node->GetObject<MobilityModel> ()->GetPosition ();
-              outFile << "set label \"" << mmuedev->GetImsi ()
-                      << "\" at "<< pos.x << "," << pos.y << " left font \"Helvetica,8\" textcolor rgb \"black\" front point pt 1 ps 0.3 lc rgb \"black\" offset 0,0"
-                      << std::endl;
-            }
-          else if (mcuedev)
-           {
-              Vector pos = node->GetObject<MobilityModel> ()->GetPosition ();
-              outFile << "set label \"" << mcuedev->GetImsi ()
-                      << "\" at "<< pos.x << "," << pos.y << " left font \"Helvetica,8\" textcolor rgb \"black\" front point pt 1 ps 0.3 lc rgb \"black\" offset 0,0"
-                      << std::endl;
-            } 
-        }
-    }
-}
-
-void 
-PrintGnuplottableEnbListToFile (std::string filename)
-{
-  std::ofstream outFile;
-  outFile.open (filename.c_str (), std::ios_base::out | std::ios_base::trunc);
-  if (!outFile.is_open ())
-    {
-      NS_LOG_ERROR ("Can't open file " << filename);
-      return;
-    }
-  for (NodeList::Iterator it = NodeList::Begin (); it != NodeList::End (); ++it)
-    {
-      Ptr<Node> node = *it;
-      int nDevs = node->GetNDevices ();
-      for (int j = 0; j < nDevs; j++)
-        {
-          Ptr<LteEnbNetDevice> enbdev = node->GetDevice (j)->GetObject <LteEnbNetDevice> ();
-          Ptr<MmWaveEnbNetDevice> mmdev = node->GetDevice (j)->GetObject <MmWaveEnbNetDevice> ();
-          Ptr<MmWaveIabNetDevice> mmIabdev = node->GetDevice (j)->GetObject <MmWaveIabNetDevice> ();
-
-          if (enbdev)
-            {
-              Vector pos = node->GetObject<MobilityModel> ()->GetPosition ();
-              outFile << "set label \"" << enbdev->GetCellId ()
-                      << "\" at "<< pos.x << "," << pos.y
-                      << " left font \"Helvetica,8\" textcolor rgb \"blue\" front  point pt 4 ps 0.3 lc rgb \"blue\" offset 0,0"
-                      << std::endl;
-            }
-          else if (mmdev)
-            {
-              Vector pos = node->GetObject<MobilityModel> ()->GetPosition ();
-              outFile << "set label \"" << mmdev->GetCellId ()
-                      << "\" at "<< pos.x << "," << pos.y
-                      << " left font \"Helvetica,8\" textcolor rgb \"red\" front  point pt 4 ps 0.3 lc rgb \"red\" offset 0,0"
-                      << std::endl;
-            } 
-         else if (mmIabdev)
-            {
-              Vector pos = node->GetObject<MobilityModel> ()->GetPosition ();
-              outFile << "set label \"" << mmIabdev->GetCellId ()
-                      << "\" at "<< pos.x << "," << pos.y
-                      << " left font \"Helvetica,8\" textcolor rgb \"red\" front  point pt 4 ps 0.3 lc rgb \"red\" offset 0,0"
-                      << std::endl;
-            } 
-        }
-    }
-}
-
-int
-main (int argc, char *argv[])
-{
-  LogComponentEnableAll (LOG_PREFIX_TIME);
-  LogComponentEnableAll (LOG_PREFIX_FUNC);
-  LogComponentEnableAll (LOG_PREFIX_NODE);
-  // LogComponentEnable("EpcEnbApplication", LOG_LEVEL_LOGIC);
-  LogComponentEnable("EpcIabApplication", LOG_LEVEL_LOGIC);
-  // LogComponentEnable("EpcSgwPgwApplication", LOG_LEVEL_LOGIC);
-  // LogComponentEnable("EpcMmeApplication", LOG_LEVEL_LOGIC);
-  // LogComponentEnable("EpcUeNas", LOG_LEVEL_LOGIC);
-
-  LogComponentEnable("LteEnbRrc", LOG_LEVEL_INFO);
-  LogComponentEnable("LteUeRrc", LOG_LEVEL_INFO);
-  LogComponentEnable("MmWaveHelper", LOG_LEVEL_LOGIC);
-  LogComponentEnable("MmWavePointToPointEpcHelper", LOG_LEVEL_LOGIC);
-  //LogComponentEnable("EpcS1ap", LOG_LEVEL_LOGIC);
-  // LogComponentEnable("EpcTftClassifier", LOG_LEVEL_LOGIC);
-  // LogComponentEnable("EpcGtpuHeader", LOG_LEVEL_INFO);
-  // LogComponentEnable("UdpEchoClientApplication", LOG_LEVEL_INFO);
-  // LogComponentEnable("UdpEchoServerApplication", LOG_LEVEL_INFO);
-  LogComponentEnable("UdpClient", LOG_LEVEL_INFO);
-  LogComponentEnable("UdpServer", LOG_LEVEL_INFO);
-  LogComponentEnable("MmWaveIabNetDevice", LOG_LEVEL_INFO);
-
-  
-  CommandLine cmd;
-  unsigned run = 0;
-  bool rlcAm = false;
-  uint32_t numRelays = 1;
-  uint32_t rlcBufSize = 10;
-  uint32_t interPacketInterval = 200;
-  cmd.AddValue("run", "run for RNG (for generating different deterministic sequences for different drops)", run);
-  cmd.AddValue("am", "RLC AM if true", rlcAm);
-  cmd.AddValue("numRelay", "Number of relays", numRelays);
-  cmd.AddValue("rlcBufSize", "RLC buffer size [MB]", rlcBufSize);
-  cmd.AddValue("intPck", "interPacketInterval [us]", interPacketInterval);
-  cmd.Parse(argc, argv);
-
-  //   if(rlcAm)
-  // {
-    LogComponentEnable("LteRlcAm", LOG_LEVEL_LOGIC); 
-  // }
-  // else
-  // {
-  // LogComponentEnable("MmWaveFlexTtiMacScheduler", LOG_LEVEL_DEBUG);
-  // // LogComponentEnable("MmWaveSpectrumPhy", LOG_LEVEL_INFO);
-  // LogComponentEnable("MmWaveEnbPhy", LOG_LEVEL_DEBUG);
-  // LogComponentEnable("MmWaveUeMac", LOG_LEVEL_DEBUG);
-  // LogComponentEnable("MmWaveEnbMac", LOG_LEVEL_DEBUG);
-  // }
-
-  Config::SetDefault("ns3::MmWavePhyMacCommon::UlSchedDelay", UintegerValue(1));
-  Config::SetDefault ("ns3::LteRlcAm::MaxTxBufferSize", UintegerValue (rlcBufSize * 1024 * 1024));
-  Config::SetDefault ("ns3::LteRlcUm::MaxTxBufferSize", UintegerValue (rlcBufSize * 1024 * 1024));
-  Config::SetDefault ("ns3::LteRlcAm::PollRetransmitTimer", TimeValue(MilliSeconds(1.0)));
-  Config::SetDefault ("ns3::LteRlcAm::ReorderingTimer", TimeValue(MilliSeconds(2.0)));
-  Config::SetDefault ("ns3::LteRlcAm::StatusProhibitTimer", TimeValue(MicroSeconds(500)));
-  Config::SetDefault ("ns3::LteRlcAm::ReportBufferStatusTimer", TimeValue(MicroSeconds(500)));
-  Config::SetDefault ("ns3::LteRlcUm::ReportBufferStatusTimer", TimeValue(MicroSeconds(500)));
-  Config::SetDefault ("ns3::MmWaveHelper::RlcAmEnabled", BooleanValue(rlcAm));
-
-  Config::SetDefault ("ns3::MmWaveFlexTtiMacScheduler::CqiTimerThreshold", UintegerValue(100));
-
-  Config::SetDefault ("ns3::MmWave3gppPropagationLossModel::Scenario", StringValue("UMi-StreetCanyon"));
-
-
-	RngSeedManager::SetSeed (1);
-	RngSeedManager::SetRun (run);
-
-  Config::SetDefault ("ns3::MmWavePhyMacCommon::SymbolsPerSubframe", UintegerValue(240));
-  Config::SetDefault ("ns3::MmWavePhyMacCommon::SubframePeriod", DoubleValue(1000));
-  Config::SetDefault ("ns3::MmWavePhyMacCommon::SymbolPeriod", DoubleValue(1000/240));
-
-  Ptr<MmWaveHelper> mmwaveHelper = CreateObject<MmWaveHelper> ();
-  mmwaveHelper->SetAttribute ("PathlossModel", StringValue ("ns3::MmWave3gppBuildingsPropagationLossModel"));
-  Ptr<MmWavePointToPointEpcHelper>  epcHelper = CreateObject<MmWavePointToPointEpcHelper> ();
-  mmwaveHelper->SetEpcHelper (epcHelper);
-  mmwaveHelper->Initialize();
-
-  ConfigStore inputConfig;
-  inputConfig.ConfigureDefaults();
-
-  // parse again so you can override default values from the command line
-  cmd.Parse(argc, argv);
-
-  Ptr<Node> pgw = epcHelper->GetPgwNode ();
-
-   // Create a single RemoteHost
-  NodeContainer remoteHostContainer;
-  remoteHostContainer.Create (1);
-  Ptr<Node> remoteHost = remoteHostContainer.Get (0);
-  InternetStackHelper internet;
-  internet.Install (remoteHostContainer);
-
-  // Create the Internet
-  PointToPointHelper p2ph;
-  p2ph.SetDeviceAttribute ("DataRate", DataRateValue (DataRate ("100Gb/s")));
-  p2ph.SetDeviceAttribute ("Mtu", UintegerValue (1500));
-  p2ph.SetChannelAttribute ("Delay", TimeValue (Seconds (0.010)));
-  NetDeviceContainer internetDevices = p2ph.Install (pgw, remoteHost);
-  Ipv4AddressHelper ipv4h;
-  ipv4h.SetBase ("1.0.0.0", "255.0.0.0");
-  Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign (internetDevices);
-  // interface 0 is localhost, 1 is the p2p device
-  // Ipv4Address remoteHostAddr = internetIpIfaces.GetAddress (1);
-
-  Ipv4StaticRoutingHelper ipv4RoutingHelper;
-  Ptr<Ipv4StaticRouting> remoteHostStaticRouting = ipv4RoutingHelper.GetStaticRouting (remoteHost->GetObject<Ipv4> ());
-  remoteHostStaticRouting->AddNetworkRouteTo (Ipv4Address ("7.0.0.0"), Ipv4Mask ("255.0.0.0"), 1);
-
-  // place buildings
-  int numBuildingsRow = 4;
-  int numBuildingsColumn = 4;
-  double streetWidth = 10; // m
-  double buildingWidthX = 50; // m
-  double buildingWidthY = 50; // m
-  double buildingHeight = 10; // m
-  std::vector< Ptr<Building> > buildingVector; // in case you need to access the buildings later
-
-  for (int rowIndex = 0; rowIndex < numBuildingsRow; ++rowIndex)
-  {
-    double minYBuilding = rowIndex*(buildingWidthY + streetWidth);
-    for (int colIndex = 0; colIndex < numBuildingsColumn; ++colIndex)
-    {
-      double minXBuilding = colIndex*(buildingWidthX + streetWidth);
-      Ptr <Building> building;
-      building = Create<Building> ();
-      building->SetBoundaries (Box( minXBuilding, minXBuilding + buildingWidthX,
-                                    minYBuilding, minYBuilding + buildingWidthY,
-                                    0.0, buildingHeight));
-      building->SetNRoomsX(1);
-      building->SetNRoomsY(1);
-      building->SetNFloors(1);
-
-      buildingVector.push_back(building);
-      Box buildingBoxForLog = building->GetBoundaries();
-      NS_LOG_INFO("Created building between coordinates (" 
-        << buildingBoxForLog.xMin << ", " << buildingBoxForLog.yMin << "), ("
-        << buildingBoxForLog.xMax << ", " << buildingBoxForLog.yMin << "), ("
-        << buildingBoxForLog.xMin << ", " << buildingBoxForLog.yMax << "), ("
-        << buildingBoxForLog.xMax << ", " << buildingBoxForLog.yMax << ") "
-        << "with height " << buildingBoxForLog.zMax - buildingBoxForLog.zMin << " m");
-    }
-  }
-
-
-  double xMax = numBuildingsRow*(buildingWidthX + streetWidth) - streetWidth;
-  double yMax = numBuildingsColumn*(buildingWidthY + streetWidth) - streetWidth;
-  double totalArea = xMax * yMax;
-
-  double gnbHeight = buildingHeight + 5;
-
-  double xWired = numBuildingsRow*(buildingWidthX+streetWidth)/2 - streetWidth/2;
-  double yWired = numBuildingsColumn*(buildingWidthY+streetWidth)/2 - streetWidth/2;
-
-  double xIab1 = numBuildingsRow*(buildingWidthX+streetWidth)/4 - streetWidth/2;
-  double xIab2 = 3*numBuildingsRow*(buildingWidthX+streetWidth)/4 - streetWidth/2;
-  double yIab1 = numBuildingsColumn*(buildingWidthY+streetWidth)/4 - streetWidth/2 ;
-  double yIab2 = 3*numBuildingsColumn*(buildingWidthY+streetWidth)/4 - streetWidth/2;
-
-  Vector posIab1 = Vector(xIab1, yIab1, gnbHeight);
-  Vector posIab2 = Vector(xIab1, yIab2, gnbHeight);
-  Vector posIab3 = Vector(xIab2, yIab1, gnbHeight);
-  Vector posIab4 = Vector(xIab2, yIab2, gnbHeight);
-  Vector posWired = Vector(xWired, yWired, gnbHeight);
-
-  NS_LOG_UNCOND("wired " << posWired << 
-                " iab1 " << posIab1 <<
-                " iab2 " << posIab2 <<
-                " iab3 " << posIab3 << 
-                " iab4 " << posIab4 << 
-                " totalArea " << totalArea
-                );
-
-  NodeContainer ueNodes;
-  NodeContainer enbNodes;
-  NodeContainer iabNodes;
- 
-  enbNodes.Create(1);
-  iabNodes.Create(numRelays);
-  ueNodes.Create(40);
-
-  // Install Mobility Model
-  Ptr<ListPositionAllocator> enbPositionAlloc = CreateObject<ListPositionAllocator> ();
-  enbPositionAlloc->Add (posWired);
-  MobilityHelper enbmobility;
-  enbmobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
-  enbmobility.SetPositionAllocator(enbPositionAlloc);
-  enbmobility.Install (enbNodes);
-
-  if(numRelays > 0)
-  { 
-    Ptr<ListPositionAllocator> iabPositionAlloc = CreateObject<ListPositionAllocator> ();
-    iabPositionAlloc->Add (posIab1);
-    iabPositionAlloc->Add (posIab2);
-    iabPositionAlloc->Add (posIab3);
-    iabPositionAlloc->Add (posIab4);
-    MobilityHelper iabmobility;
-    iabmobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
-    iabmobility.SetPositionAllocator (iabPositionAlloc);
-    iabmobility.Install (iabNodes);
-  }
-
-  MobilityHelper uemobility;
-  Ptr<OutdoorPositionAllocator> uePosAlloc = CreateObject<OutdoorPositionAllocator>();
-  Ptr<UniformRandomVariable> xUe = CreateObject<UniformRandomVariable>();
-  xUe->SetAttribute("Min", DoubleValue(0));
-  xUe->SetAttribute("Max", DoubleValue(xMax));
-  uePosAlloc->SetX(xUe);
-  Ptr<UniformRandomVariable> yUe = CreateObject<UniformRandomVariable>();
-  yUe->SetAttribute("Min", DoubleValue(0));
-  yUe->SetAttribute("Max", DoubleValue(yMax));
-  uePosAlloc->SetY(yUe);
-  Ptr<UniformRandomVariable> zUe = CreateObject<UniformRandomVariable>();
-  zUe->SetAttribute("Min", DoubleValue(1.6));
-  zUe->SetAttribute("Max", DoubleValue(1.75));
-  uePosAlloc->SetZ(zUe);
-  uemobility.SetPositionAllocator (uePosAlloc);
-  uemobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
-  uemobility.Install (ueNodes);
-  
-  BuildingsHelper::Install (enbNodes);
-  if(numRelays > 0)
-  { 
-    BuildingsHelper::Install (iabNodes);
-  }
-  BuildingsHelper::Install (ueNodes);
-  BuildingsHelper::MakeMobilityModelConsistent ();
-
-  // Install mmWave Devices to the nodes
-  NetDeviceContainer enbmmWaveDevs = mmwaveHelper->InstallEnbDevice (enbNodes);
-  NetDeviceContainer iabmmWaveDevs;
-  if(numRelays > 0)
-  {
-    iabmmWaveDevs = mmwaveHelper->InstallIabDevice (iabNodes);
-  }
-  NetDeviceContainer uemmWaveDevs = mmwaveHelper->InstallUeDevice (ueNodes);
-
-  PrintGnuplottableBuildingListToFile("buildings.txt");// fileName.str ());
-  PrintGnuplottableEnbListToFile("enbs.txt");
-  PrintGnuplottableUeListToFile("ues.txt");
-
-  // Install the IP stack on the UEs
-  internet.Install (ueNodes);
-  Ipv4InterfaceContainer ueIpIface;
-  ueIpIface = epcHelper->AssignUeIpv4Address (NetDeviceContainer (uemmWaveDevs));
-  // Assign IP address to UEs, and install applications
-  for (uint32_t u = 0; u < ueNodes.GetN (); ++u)
-    {
-      Ptr<Node> ueNode = ueNodes.Get (u);
-      // Set the default gateway for the UE
-      Ptr<Ipv4StaticRouting> ueStaticRouting = ipv4RoutingHelper.GetStaticRouting (ueNode->GetObject<Ipv4> ());
-      ueStaticRouting->SetDefaultRoute (epcHelper->GetUeDefaultGatewayAddress (), 1);
-    }
-
-  NetDeviceContainer possibleBaseStations(enbmmWaveDevs, iabmmWaveDevs);
-  NS_LOG_UNCOND("number of IAB devs " << iabmmWaveDevs.GetN() << " num of possibleBaseStations " 
-    << possibleBaseStations.GetN());
-
-  if(numRelays > 0)
-  {
-    mmwaveHelper->AttachIabToClosestWiredEnb (iabmmWaveDevs, enbmmWaveDevs);
-  }
-  mmwaveHelper->AttachToClosestEnbWithDelay (uemmWaveDevs, possibleBaseStations, Seconds(0.3));
-
-  // Install and start applications on UEs and remote host
-  uint16_t dlPort = 1234;
-  // uint16_t ulPort = 2000;
-  // uint16_t otherPort = 3000;
-  ApplicationContainer clientApps;
-  ApplicationContainer serverApps;
-
-  for (uint32_t u = 0; u < ueNodes.GetN (); ++u)
-  {
-    // DL UDP
-    UdpServerHelper dlPacketSinkHelper (dlPort);
-    serverApps.Add (dlPacketSinkHelper.Install (ueNodes.Get(u)));
-
-    UdpClientHelper dlClient (ueIpIface.GetAddress (u), dlPort);
-    dlClient.SetAttribute ("Interval", TimeValue (MicroSeconds(interPacketInterval)));
-    dlClient.SetAttribute ("PacketSize", UintegerValue(1400));
-    dlClient.SetAttribute ("MaxPackets", UintegerValue(0xFFFFFFFF));
-    clientApps.Add (dlClient.Install (remoteHost));
-
-    dlPort++;
-  }
-  serverApps.Start (Seconds (0.49));
-  clientApps.Stop (Seconds (1.2));
-  clientApps.Start (Seconds (0.5));
-
-  mmwaveHelper->EnableTraces ();
-
-  Simulator::Stop(Seconds(1.2));
-  Simulator::Run();
-
-  /*GtkConfigStore config;
-  config.ConfigureAttributes();*/
-
-  Simulator::Destroy();
-  return 0;
-}
-
diff -Naru '--exclude=.git' ns3-mmwave-iab/scratch/simulation-config/ps-simulation-config.cc iab-psc/scratch/simulation-config/ps-simulation-config.cc
--- ns3-mmwave-iab/scratch/simulation-config/ps-simulation-config.cc	1970-01-01 01:00:00.000000000 +0100
+++ iab-psc/scratch/simulation-config/ps-simulation-config.cc	2019-02-15 18:13:15.423797759 +0100
@@ -0,0 +1,29 @@
+/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2019, University of Padova, Dep. of Information Engineering, SIGNET lab.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <scratch/simulation-config/ps-simulation-config.h>
+
+using namespace ns3;
+using namespace mmwave;
+
+int
+main (int argc, char *argv[])
+{
+  return 0;
+}
diff -Naru '--exclude=.git' ns3-mmwave-iab/scratch/simulation-config/ps-simulation-config.h iab-psc/scratch/simulation-config/ps-simulation-config.h
--- ns3-mmwave-iab/scratch/simulation-config/ps-simulation-config.h	1970-01-01 01:00:00.000000000 +0100
+++ iab-psc/scratch/simulation-config/ps-simulation-config.h	2019-02-15 18:13:15.423797759 +0100
@@ -0,0 +1,735 @@
+/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2019, University of Padova, Dep. of Information Engineering, SIGNET lab.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <ns3/core-module.h>
+#include <ns3/internet-module.h>
+#include <ns3/point-to-point-helper.h>
+#include <ns3/mobility-module.h>
+#include <ns3/applications-module.h>
+#include <ns3/buildings-module.h>
+#include <ns3/node-list.h>
+#include <ns3/lte-module.h>
+#include <ns3/mmwave-module.h>
+#include <ns3/trace-source-accessor.h>
+
+NS_LOG_COMPONENT_DEFINE ("PsSimulationConfig");
+
+namespace ns3{
+namespace mmwave{
+
+  class PsSimulationConfig
+  {
+    public:
+      static std::pair<Ptr<Node>, Ipv4Address> CreateInternet (Ptr<MmWavePointToPointEpcHelper> epcHelper);
+      static Ipv4InterfaceContainer InstallUeInternet (Ptr<MmWavePointToPointEpcHelper> epcHelper, NodeContainer ueNodes, NetDeviceContainer ueNetDevices);
+      static void SetConstantPositionMobility (NodeContainer nodes, Vector position);
+      static void SetConstantVelocityMobility (Ptr<Node> node, Vector position, Vector velocity);
+      static void SetupUplinkUdpFlow (Ptr<Node> source, Ptr<Node> sink, Ipv4Address sinkAddress, uint16_t port, Time interPacketInterval,
+                                      Time startTime, Time endTime, Ptr<OutputStreamWrapper> stream);
+      static void SetupUdpApplication (Ptr<Node> node, Ipv4Address address, uint16_t port, Time interPacketInterval, Time startTime, Time endTime);
+      static void SetupUdpPacketSink (Ptr<Node> node, uint16_t port, Time startTime, Time endTime, Ptr<OutputStreamWrapper> stream);
+      static void SetTracesPath (std::string filePath);
+      static void CreateRandomObstacle (double streetLength, double streetWidth, double obstacleWidth, double obstacleLength, double obstacleHeight);
+      static void DropSwatTeams (std::vector<NodeContainer> swatTeams, NodeContainer iabNodesForSwatTeams, double buildingSizeX, double buildingSizeY, double ueAntennaHeight, Ptr<UniformRandomVariable> randomSpeed, double maximumDuration);
+      static void DropSwatTeams3 (std::vector<NodeContainer> swatTeams, NodeContainer iabNodesForSwatTeams, double buildingSizeX, double buildingSizeY, double ueAntennaHeight, Ptr<UniformRandomVariable> randomSpeed);
+
+    private:
+      static void ChangeSpeed (Ptr<Node> n, Vector speed);
+  };
+
+  class CallbackSinks
+  {
+    public:
+      static void RxSink (Ptr<OutputStreamWrapper> stream, Ptr<const Packet> packet, const Address &from = Address ());
+      static void TxSink (Ptr<OutputStreamWrapper> stream, Ptr<const Packet> packet, const Address &from = Address ());
+  };
+
+  class RandomBuildings
+  {
+    public:
+      static void CreateRandomBuildings (double streetWidth, double blockSize, double maxXAxis, double maxYAxis, uint32_t numBlocks);
+
+    private:
+      static std::pair<Box, std::list<Box>> GenerateBuildingBounds(double xMin, double xMax, double yMin, double yMax, double maxBuildSize, std::list<Box> m_previousBlocks );
+      static bool AreOverlapping(Box a, Box b);
+      static bool OverlapWithAnyPrevious(Box box, std::list<Box> m_previousBlocks);
+
+  };
+
+  class GridBuildings
+  {
+    public:
+      static std::vector< Ptr<Building> > CreateGridBuildings (int numBuildingsRow, int numBuildingsColumn, double streetWidth, double buildingWidthX, double buildingWidthY, double buildingHeight);
+  };
+
+  class PrintHelper
+  {
+    public:
+      static void PrintGnuplottableBuildingListToFile (std::string filename);
+      static void PrintGnuplottableNodeListToFile (std::string filename);
+      static void UpdateGnuplottableNodeListToFile (std::string filename, Ptr<Node> node);
+  };
+
+  std::pair<Ptr<Node>, Ipv4Address>
+  PsSimulationConfig::CreateInternet (Ptr<MmWavePointToPointEpcHelper> epcHelper)
+  {
+    // Create the Internet by connecting remoteHost to pgw. Setup routing too
+    Ptr<Node> pgw = epcHelper->GetPgwNode ();
+
+    // Create remotehost
+    NodeContainer remoteHostContainer;
+    remoteHostContainer.Create (1);
+    InternetStackHelper internet;
+    internet.Install (remoteHostContainer);
+    Ipv4StaticRoutingHelper ipv4RoutingHelper;
+    Ipv4InterfaceContainer internetIpIfaces;
+
+    Ptr<Node> remoteHost = remoteHostContainer.Get (0);
+    // Create the Internet
+    PointToPointHelper p2ph;
+    p2ph.SetDeviceAttribute ("DataRate", DataRateValue (DataRate ("100Gb/s")));
+    p2ph.SetDeviceAttribute ("Mtu", UintegerValue (1500));
+    p2ph.SetChannelAttribute ("Delay", TimeValue (Seconds (0.001)));
+
+    NetDeviceContainer internetDevices = p2ph.Install (pgw, remoteHost);
+
+    Ipv4AddressHelper ipv4h;
+    ipv4h.SetBase ("1.0.0.0", "255.255.0.0");
+    internetIpIfaces = ipv4h.Assign (internetDevices);
+    // interface 0 is localhost, 1 is the p2p device
+    Ipv4Address remoteHostAddr = internetIpIfaces.GetAddress (1);
+
+    Ptr<Ipv4StaticRouting> remoteHostStaticRouting = ipv4RoutingHelper.GetStaticRouting (remoteHost->GetObject<Ipv4> ());
+    remoteHostStaticRouting->AddNetworkRouteTo (Ipv4Address ("7.0.0.0"), Ipv4Mask ("255.255.0.0"), 1);
+
+    return std::pair<Ptr<Node>, Ipv4Address> (remoteHost, remoteHostAddr);
+  }
+
+  Ipv4InterfaceContainer
+  PsSimulationConfig::InstallUeInternet (Ptr<MmWavePointToPointEpcHelper> epcHelper, NodeContainer ueNodes, NetDeviceContainer ueNetDevices)
+  {
+    // Install the IP stack on the UEs
+    InternetStackHelper internet;
+    internet.Install (ueNodes);
+    Ipv4InterfaceContainer ueIpIface;
+    ueIpIface = epcHelper->AssignUeIpv4Address (ueNetDevices);
+    // Assign IP address to UEs, and install applications
+    // Set the default gateway for the UE
+    Ipv4StaticRoutingHelper ipv4RoutingHelper;
+
+    for (uint32_t i = 0; i < ueNodes.GetN (); i++)
+    {
+      Ptr<Ipv4StaticRouting> ueStaticRouting = ipv4RoutingHelper.GetStaticRouting (ueNodes.Get (i)->GetObject<Ipv4> ());
+      ueStaticRouting->SetDefaultRoute (epcHelper->GetUeDefaultGatewayAddress (), 1);
+    }
+
+    return ueIpIface;
+  }
+
+  void
+  PsSimulationConfig::SetConstantPositionMobility (NodeContainer nodes, Vector position)
+  {
+    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator> ();
+    positionAlloc->Add (position);
+    MobilityHelper mobility;
+    mobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
+    mobility.SetPositionAllocator(positionAlloc);
+    mobility.Install (nodes);
+    BuildingsHelper::Install (nodes);
+  }
+
+  void
+  PsSimulationConfig::SetConstantVelocityMobility (Ptr<Node> node, Vector position, Vector velocity)
+  {
+    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator> ();
+    MobilityHelper mobility;
+    positionAlloc->Add (position);
+    mobility.SetMobilityModel ("ns3::ConstantVelocityMobilityModel");
+    mobility.SetPositionAllocator(positionAlloc);
+    mobility.Install (node);
+    node->GetObject<ConstantVelocityMobilityModel> ()->SetVelocity (velocity);
+    BuildingsHelper::Install (node);
+  }
+
+  void
+  PsSimulationConfig::SetupUplinkUdpFlow (Ptr<Node> source, Ptr<Node> sink, Ipv4Address sinkAddress, uint16_t port, Time interPacketInterval, Time startTime, Time endTime, Ptr<OutputStreamWrapper> stream)
+  {
+    SetupUdpApplication (source, sinkAddress, port, interPacketInterval, startTime, endTime);
+    SetupUdpPacketSink (sink, port, startTime, endTime, stream);
+  }
+
+  void
+  PsSimulationConfig::SetupUdpApplication (Ptr<Node> node, Ipv4Address address, uint16_t port, Time interPacketInterval, Time startTime, Time endTime)
+  {
+    ApplicationContainer app;
+    UdpClientHelper client (address, port);
+    client.SetAttribute ("Interval", TimeValue (interPacketInterval));
+    client.SetAttribute ("MaxPackets", UintegerValue(0xFFFFFFFF));
+
+    app.Add (client.Install (node));
+    app.Start (startTime);
+    app.Stop (endTime);
+
+    NS_LOG_INFO ("Number of packets to send " << std::floor((endTime.GetSeconds ()-startTime.GetSeconds ()) / interPacketInterval.GetSeconds ()));
+  }
+
+  void
+  PsSimulationConfig::SetupUdpPacketSink (Ptr<Node> node, uint16_t port, Time startTime, Time endTime, Ptr<OutputStreamWrapper> stream)
+  {
+    ApplicationContainer app;
+    PacketSinkHelper packetSinkHelper ("ns3::UdpSocketFactory", InetSocketAddress (Ipv4Address::GetAny (), port));
+    app.Add (packetSinkHelper.Install (node));
+    app.Start (startTime);
+    app.Stop (endTime);
+
+    app.Get(0)->TraceConnectWithoutContext("Rx", MakeBoundCallback (&CallbackSinks::RxSink, stream));
+  }
+
+  void
+  PsSimulationConfig::SetTracesPath (std::string filePath)
+  {
+    Config::SetDefault("ns3::MmWaveBearerStatsCalculator::DlRlcOutputFilename", StringValue(filePath + "DlRlcStats.txt"));
+    Config::SetDefault("ns3::MmWaveBearerStatsCalculator::UlRlcOutputFilename", StringValue(filePath + "UlRlcStats.txt"));
+    Config::SetDefault("ns3::MmWaveBearerStatsCalculator::DlPdcpOutputFilename", StringValue(filePath + "DlPdcpStats.txt"));
+    Config::SetDefault("ns3::MmWaveBearerStatsCalculator::UlPdcpOutputFilename", StringValue(filePath + "UlPdcpStats.txt"));
+    // Config::SetDefault("ns3::MmWavePhyRxTrace::OutputFilename", StringValue(filePath + "RxPacketTrace.txt"));
+    Config::SetDefault("ns3::LteRlcAm::BufferSizeFilename", StringValue(filePath + "RlcAmBufferSize.txt"));
+  }
+
+  void
+  PsSimulationConfig::CreateRandomObstacle (double streetLength, double streetWidth, double obstacleWidth, double obstacleLength, double obstacleHeight)
+  {
+    NS_ASSERT_MSG (obstacleWidth <= obstacleLength, "Width has to be smaller or equal than length");
+
+    // choose a random orientation for the obstacle
+    // true = landscape, false = potrait
+    Ptr<UniformRandomVariable> rnd = CreateObject<UniformRandomVariable> ();
+    rnd->SetAttribute ("Min", DoubleValue (0.0));
+    rnd->SetAttribute ("Max", DoubleValue (1.0));
+    bool orientation = (rnd->GetValue () > 0.5);
+
+    // choose randomly the position of the obstacle
+    Ptr<UniformRandomVariable> x = CreateObject<UniformRandomVariable> ();
+    Ptr<UniformRandomVariable> y = CreateObject<UniformRandomVariable> ();
+    Box box;
+
+    if (orientation)
+    {
+      // landscape
+      //--------------------------
+      //        length
+      //      ------------
+      //      |          | width
+      //      ------------
+      //--------------------------
+      x->SetAttribute ("Max", DoubleValue (streetLength - obstacleLength));
+      y->SetAttribute ("Max", DoubleValue (streetWidth - obstacleWidth));
+      box.xMin = x->GetValue ();
+      box.xMax = box.xMin + obstacleLength;
+      box.yMin = y->GetValue ();
+      box.yMax = box.yMin + obstacleWidth;
+
+      NS_LOG_INFO ("Landscape orientation, x = " << box.xMin << ":" << box.xMax << ", y = " << box.yMin << ":" << box.yMax);
+    }
+    else
+    {
+      // potrait
+      //--------------------------
+      //      width
+      //      -----
+      //      |   |
+      //      |   | length
+      //      |   |
+      //      -----
+      //--------------------------
+      std::cout << "streetLength-obstacleWidth " << streetLength - obstacleWidth << std::endl;
+      x->SetAttribute ("Max", DoubleValue (streetLength - obstacleWidth));
+      std::cout << "streetWidth-obstacleLength " << streetWidth - obstacleLength << std::endl;
+      y->SetAttribute ("Max", DoubleValue (streetWidth - obstacleLength));
+      box.xMin = x->GetValue ();
+      box.xMax = box.xMin + obstacleWidth;
+      box.yMin = y->GetValue ();
+      box.yMax = box.yMin + obstacleLength;
+
+      NS_LOG_INFO ("Potrait orientation, x = " << box.xMin << ":" << box.xMax << ", y = " << box.yMin << ":" << box.yMax);
+    }
+
+    // set the obstacle height
+    box.zMax = obstacleHeight;
+
+    // create an instance of the Building class which represents the obstacle
+    Ptr<Building> obstacle = Create<Building> ();
+    obstacle->SetBoundaries (box);
+    obstacle->SetNRoomsX(1);
+    obstacle->SetNRoomsY(1);
+    obstacle->SetNFloors(1);
+  }
+
+  void
+  PsSimulationConfig::DropSwatTeams (std::vector<NodeContainer> swatTeams, NodeContainer iabNodesForSwatTeams, double buildingSizeX, double buildingSizeY, double ueAntennaHeight, Ptr<UniformRandomVariable> randomSpeed, double maximumDuration)
+  {
+    std::vector<Vector> buildingCorners;
+    buildingCorners.push_back (Vector(-1, -1, 0));
+    buildingCorners.push_back (Vector(buildingSizeX + 1, -1, 0));
+    buildingCorners.push_back (Vector(buildingSizeX + 1, buildingSizeY + 1, 0));
+    buildingCorners.push_back (Vector(-1, buildingSizeY + 1, 0));
+
+    for (uint32_t swIndex = 0; swIndex < swatTeams.size (); ++swIndex)
+    {
+      MobilityHelper mobility;
+      mobility.SetMobilityModel ("ns3::ConstantVelocityMobilityModel");
+      Ptr<ListPositionAllocator> position = CreateObject<ListPositionAllocator> ();
+      Vector cornerPosition = buildingCorners.at((swIndex % 4)); // at most 4 corners
+      cornerPosition.z = ueAntennaHeight;
+      position->Add (cornerPosition);
+      mobility.SetPositionAllocator(position);
+      double randomSpeedTeam = randomSpeed->GetValue();
+      double timeToCoverX = buildingSizeX / 2 / randomSpeedTeam;
+      double timeToCoverY = buildingSizeY / 2 / randomSpeedTeam;
+      double startTimeY = maximumDuration - timeToCoverY;
+      double startTimeX = startTimeY - timeToCoverX;
+
+      Ptr<GroupMobilityHelper> groupMobility = CreateObject<GroupMobilityHelper>();
+      groupMobility->SetAttribute("GroupSlaveMobilityModel", StringValue("ns3::GroupSlaveOutdoorMobilityModel"));
+      groupMobility->SetAttribute("PathDeviationRandomVariable", StringValue("ns3::NormalRandomVariable[Mean=0.0|Variance=0.5|Bound=1.2]"));
+
+      groupMobility->SetMobilityHelper(&mobility);
+      NodeContainer allNodesTeam = groupMobility->InstallGroupMobility (NodeContainer(swatTeams.at(swIndex)));
+
+      BuildingsHelper::Install(allNodesTeam);
+
+      double speedX = ((swIndex % 4) == 0 || (swIndex % 4) == 3) ? randomSpeedTeam : -randomSpeedTeam;
+      double speedY = ((swIndex % 4) <= 1) ? randomSpeedTeam : -randomSpeedTeam;
+
+      Simulator::Schedule(Seconds(0), &ChangeSpeed, allNodesTeam.Get(0), Vector (0, 0, 0));
+      Simulator::Schedule(Seconds(startTimeX), &ChangeSpeed, allNodesTeam.Get(0), Vector (speedX, 0, 0));
+      Simulator::Schedule(Seconds(startTimeY), &ChangeSpeed, allNodesTeam.Get(0), Vector (0, speedY, 0));
+
+      // use a different mobility model for the iab nodes
+      // create a random variable to randomize the initial position of the IAB
+      // node
+      Ptr<NormalRandomVariable> pathDeviationRandomVariable = CreateObject<NormalRandomVariable> ();
+      pathDeviationRandomVariable->SetAttribute ("Mean", DoubleValue (0.0));
+      pathDeviationRandomVariable->SetAttribute ("Variance", DoubleValue (0.5));
+      pathDeviationRandomVariable->SetAttribute ("Bound", DoubleValue (1));
+      Vector iabInitialPos = buildingCorners.at((swIndex % 4));
+      iabInitialPos.y = iabInitialPos.y + pathDeviationRandomVariable->GetValue ();
+      iabInitialPos.z = ueAntennaHeight;
+      SetConstantVelocityMobility (iabNodesForSwatTeams.Get(swIndex), iabInitialPos, Vector (0, 0, 0));
+      Simulator::Schedule(Seconds(startTimeX), &ChangeSpeed, iabNodesForSwatTeams.Get(swIndex), Vector (speedX, 0, 0));
+      // stop before the corner
+      Simulator::Schedule(Seconds(startTimeY), &ChangeSpeed, iabNodesForSwatTeams.Get(swIndex), Vector (0, 0, 0));
+
+      NS_LOG_DEBUG ("swIndex " << swIndex << " speedX " << speedX << " startTimeX " << startTimeX << " speedY " << speedY << " startTimeY " << startTimeY);
+    }
+  }
+
+  void
+  PsSimulationConfig::DropSwatTeams3 (std::vector<NodeContainer> swatTeams, NodeContainer iabNodesForSwatTeams, double buildingSizeX, double buildingSizeY, double ueAntennaHeight, Ptr<UniformRandomVariable> randomSpeed)
+  {
+    std::vector<Vector> initialPositions;
+    initialPositions.push_back (Vector(buildingSizeX / 2, buildingSizeY / 4, 0));
+    initialPositions.push_back (Vector(buildingSizeX - buildingSizeX / 4, buildingSizeY / 2, 0));
+    initialPositions.push_back (Vector(buildingSizeX / 2, buildingSizeY - buildingSizeY / 4, 0));
+    initialPositions.push_back (Vector(buildingSizeX / 4 , buildingSizeY / 2, 0));
+
+    for (uint32_t swIndex = 0; swIndex < swatTeams.size (); ++swIndex)
+    {
+      MobilityHelper mobility;
+      mobility.SetMobilityModel ("ns3::ConstantVelocityMobilityModel");
+      Ptr<ListPositionAllocator> position = CreateObject<ListPositionAllocator> ();
+      Vector cornerPosition = initialPositions.at((swIndex % 4)); // at most 4 corners
+      cornerPosition.z = ueAntennaHeight;
+      position->Add (cornerPosition);
+      mobility.SetPositionAllocator(position);
+      double randomSpeedTeam = randomSpeed->GetValue();
+
+      Ptr<GroupMobilityHelper> groupMobility = CreateObject<GroupMobilityHelper>();
+      groupMobility->SetAttribute("GroupSlaveMobilityModel", StringValue("ns3::GroupSlaveOutdoorMobilityModel"));
+      groupMobility->SetAttribute("PathDeviationRandomVariable", StringValue("ns3::NormalRandomVariable[Mean=0.0|Variance=0.5|Bound=1.2]"));
+
+      groupMobility->SetMobilityHelper(&mobility);
+      NodeContainer allNodesTeam = groupMobility->InstallGroupMobility (NodeContainer(swatTeams.at(swIndex)));
+
+      BuildingsHelper::Install(allNodesTeam);
+
+      if (swIndex == 0)
+      {
+        Simulator::Schedule(Seconds(0), &ChangeSpeed, allNodesTeam.Get(0), Vector (0.0, randomSpeedTeam, 0.0));
+        // stop at the center of the building
+        Simulator::Schedule (Seconds (buildingSizeY / 4 / randomSpeedTeam), &ChangeSpeed, allNodesTeam.Get(0), Vector (0.0, 0.0, 0.0));
+        NS_LOG_DEBUG ("Swat team " << swIndex << " stops at " << buildingSizeY / 4 / randomSpeedTeam);
+      }
+      else if (swIndex == 1)
+      {
+        Simulator::Schedule(Seconds(0), &ChangeSpeed, allNodesTeam.Get(0), Vector (-randomSpeedTeam, 0.0, 0.0));
+        // stop at the center of the building
+        Simulator::Schedule (Seconds (buildingSizeX / 4 / randomSpeedTeam), &ChangeSpeed, allNodesTeam.Get(0), Vector (0.0, 0.0, 0.0));
+        NS_LOG_DEBUG ("Swat team " << swIndex << " stops at " << buildingSizeX / 4 / randomSpeedTeam);
+      }
+      else if (swIndex == 2)
+      {
+        Simulator::Schedule(Seconds(0), &ChangeSpeed, allNodesTeam.Get(0), Vector (0.0, -randomSpeedTeam, 0.0));
+        // stop at the center of the building
+        Simulator::Schedule (Seconds (buildingSizeY / 4 / randomSpeedTeam), &ChangeSpeed, allNodesTeam.Get(0), Vector (0.0, 0.0, 0.0));
+        NS_LOG_DEBUG ("Swat team " << swIndex << " stops at " << buildingSizeY / 4 / randomSpeedTeam);
+      }
+      else if (swIndex == 3)
+      {
+        Simulator::Schedule(Seconds(0), &ChangeSpeed, allNodesTeam.Get(0), Vector (randomSpeedTeam, 0.0, 0.0));
+        // stop at the center of the building
+        Simulator::Schedule (Seconds (buildingSizeX / 4 / randomSpeedTeam), &ChangeSpeed, allNodesTeam.Get(0), Vector (0.0, 0.0, 0.0));
+        NS_LOG_DEBUG ("Swat team " << swIndex << " stops at " << buildingSizeX / 4 / randomSpeedTeam);
+      }
+      else
+      {
+        NS_FATAL_ERROR ("up to 4 swats teams supported");
+      }
+
+      if (iabNodesForSwatTeams.GetN () != 0)
+      {
+        // use a different mobility model for the iab nodes
+        // create a random variable to randomize the initial position of the IAB
+        // node
+        Vector iabInitialPos;
+        if (swIndex == 0)
+        {
+          iabInitialPos = Vector(buildingSizeX / 2, -10 , 0);
+        }
+        else if (swIndex == 1)
+        {
+          iabInitialPos = Vector(buildingSizeX + 10, buildingSizeY / 2, 0);
+        }
+        else if (swIndex == 2)
+        {
+          iabInitialPos = Vector(buildingSizeX / 2, buildingSizeY + 10 , 0);
+        }
+        else if (swIndex == 3)
+        {
+          iabInitialPos = Vector(-10, buildingSizeY / 2, 0);
+        }
+        else
+        {
+          NS_FATAL_ERROR ("up to 4 swats teams supported");
+        }
+        SetConstantPositionMobility (iabNodesForSwatTeams.Get(swIndex), iabInitialPos);
+      }
+    }
+  }
+
+  void
+  PsSimulationConfig::ChangeSpeed (Ptr<Node> n, Vector speed)
+  {
+    n->GetObject<ConstantVelocityMobilityModel> ()->SetVelocity (speed);
+    NS_LOG_UNCOND ("************************--------------------Change Speed-------------------------------*****************");
+  }
+
+  void
+  RandomBuildings::CreateRandomBuildings (double streetWidth, double blockSize, double maxXAxis, double maxYAxis, uint32_t numBlocks)
+  {
+    /* Create the building */
+  	 double maxObstacleSize = blockSize - streetWidth;
+
+  	 std::vector<Ptr<Building> > buildingVector;
+  	 std::list<Box>  m_previousBlocks;
+
+  	 for(uint32_t buildingIndex = 0; buildingIndex < numBlocks; buildingIndex++)
+  	 {
+  		 Ptr < Building > building;
+  		 building = Create<Building> ();
+  		 /* returns a vecotr where:
+  		 * position [0]: coordinates for x min
+  		 * position [1]: coordinates for x max
+  		 * position [2]: coordinates for y min
+  		 * position [3]: coordinates for y max
+  		 */
+
+  		 std::pair<Box, std::list<Box>> pairBuildings = RandomBuildings::GenerateBuildingBounds(0, maxXAxis-maxObstacleSize, 0, maxYAxis-maxObstacleSize, maxObstacleSize, m_previousBlocks);
+  		 m_previousBlocks = std::get<1>(pairBuildings);
+  	 	 Box box = std::get<0>(pairBuildings);
+
+  		 Ptr<UniformRandomVariable> randomBuildingZ = CreateObject<UniformRandomVariable>();
+  		 randomBuildingZ->SetAttribute("Min",DoubleValue(1.6));
+  		 randomBuildingZ->SetAttribute("Max",DoubleValue(50));
+  		 double buildingHeight = randomBuildingZ->GetValue();
+       NS_LOG_INFO ("Building height " << buildingHeight << "\n");
+
+  		 building->SetBoundaries (Box(box.xMin, box.xMax,
+  																	 box.yMin,  box.yMax,
+  																	 0.0, buildingHeight));
+
+  		 building->SetNRoomsX(1);
+  		 building->SetNRoomsY(1);
+  		 building->SetNFloors(1);
+  		 buildingVector.push_back(building);
+  	 }
+  		/* END Create the building */
+  }
+
+  std::vector< Ptr<Building> >
+  GridBuildings::CreateGridBuildings (
+    int numBuildingsRow,
+    int numBuildingsColumn,
+    double streetWidth,
+    double buildingWidthX,
+    double buildingWidthY,
+    double buildingHeight)
+  {
+    std::vector< Ptr<Building> > buildingVector; // in case you need to access the buildings later
+
+    for (int rowIndex = 0; rowIndex < numBuildingsRow; ++rowIndex)
+    {
+      double minYBuilding = rowIndex*(buildingWidthY + streetWidth);
+      for (int colIndex = 0; colIndex < numBuildingsColumn; ++colIndex)
+      {
+        double minXBuilding = colIndex*(buildingWidthX + streetWidth);
+        Ptr <Building> building;
+        building = Create<Building> ();
+        building->SetBoundaries (Box( minXBuilding, minXBuilding + buildingWidthX,
+                                      minYBuilding, minYBuilding + buildingWidthY,
+                                      0.0, buildingHeight));
+        building->SetNRoomsX(1);
+        building->SetNRoomsY(1);
+        building->SetNFloors(1);
+
+        buildingVector.push_back(building);
+        Box buildingBoxForLog = building->GetBoundaries();
+        NS_LOG_INFO("Created building between coordinates ("
+          << buildingBoxForLog.xMin << ", " << buildingBoxForLog.yMin << "), ("
+          << buildingBoxForLog.xMax << ", " << buildingBoxForLog.yMin << "), ("
+          << buildingBoxForLog.xMin << ", " << buildingBoxForLog.yMax << "), ("
+          << buildingBoxForLog.xMax << ", " << buildingBoxForLog.yMax << ") "
+          << "with height " << buildingBoxForLog.zMax - buildingBoxForLog.zMin << " m");
+      }
+    }
+
+    return buildingVector;
+  }
+
+  void
+  CallbackSinks::RxSink (Ptr<OutputStreamWrapper> stream, Ptr<const Packet> packet, const Address &from)
+  {
+    *stream->GetStream () << "Rx\t" << Simulator::Now ().GetSeconds () << "\t" << packet->GetSize() << std::endl;
+  }
+
+  void
+  CallbackSinks::TxSink (Ptr<OutputStreamWrapper> stream, Ptr<const Packet> packet, const Address &from)
+  {
+    *stream->GetStream () << "Tx\t" << Simulator::Now ().GetSeconds () << "\t" << packet->GetSize() << std::endl;
+  }
+
+  std::pair<Box, std::list<Box>>
+  RandomBuildings::GenerateBuildingBounds(double xMin, double xMax, double yMin, double yMax, double maxBuildSize, std::list<Box> m_previousBlocks )
+  {
+
+    Ptr<UniformRandomVariable> xMinBuilding = CreateObject<UniformRandomVariable>();
+    xMinBuilding->SetAttribute("Min",DoubleValue(xMin));
+    xMinBuilding->SetAttribute("Max",DoubleValue(xMax-1)); // 1 m is the minimum size
+
+    Ptr<UniformRandomVariable> yMinBuilding = CreateObject<UniformRandomVariable>();
+    yMinBuilding->SetAttribute("Min",DoubleValue(yMin));
+    yMinBuilding->SetAttribute("Max",DoubleValue(yMax-1)); // 1 m is the minimum size
+
+    Box box;
+    uint32_t attempt = 0;
+    do
+    {
+      NS_ASSERT_MSG(attempt < 100, "Too many failed attempts to position non-overlapping buildings. Maybe area too small or too many buildings?");
+      box.xMin = xMinBuilding->GetValue();
+
+      Ptr<UniformRandomVariable> xMaxBuilding = CreateObject<UniformRandomVariable>();
+      xMaxBuilding->SetAttribute("Min",DoubleValue(box.xMin + 1)); // 1 m is the minimum size
+      xMaxBuilding->SetAttribute("Max",DoubleValue(box.xMin + maxBuildSize));
+      box.xMax = xMaxBuilding->GetValue();
+
+      box.yMin = yMinBuilding->GetValue();
+
+      Ptr<UniformRandomVariable> yMaxBuilding = CreateObject<UniformRandomVariable>();
+      yMaxBuilding->SetAttribute("Min",DoubleValue(box.yMin + 1)); // 1 m is the minimum size
+      yMaxBuilding->SetAttribute("Max",DoubleValue(box.yMin + maxBuildSize));
+      box.yMax = yMaxBuilding->GetValue();
+
+      ++attempt;
+    }
+    while (OverlapWithAnyPrevious (box, m_previousBlocks));
+
+
+    NS_LOG_INFO("Building in coordinates (" << box.xMin << " , " << box.yMin << ") and ("  << box.xMax << " , " << box.yMax <<
+      ") accepted after " << attempt << " attempts");
+    m_previousBlocks.push_back(box);
+    std::pair<Box, std::list<Box>> pairReturn = std::make_pair(box,m_previousBlocks);
+    return pairReturn;
+  }
+
+  bool
+  RandomBuildings::AreOverlapping(Box a, Box b)
+  {
+    return !((a.xMin > b.xMax) || (b.xMin > a.xMax) || (a.yMin > b.yMax) || (b.yMin > a.yMax) );
+  }
+
+  bool
+  RandomBuildings::OverlapWithAnyPrevious(Box box, std::list<Box> m_previousBlocks)
+  {
+    for (std::list<Box>::iterator it = m_previousBlocks.begin(); it != m_previousBlocks.end(); ++it)
+    {
+      if (AreOverlapping(*it,box))
+      {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  void
+  PrintHelper::PrintGnuplottableBuildingListToFile (std::string filename)
+  {
+    std::ofstream outFile;
+    outFile.open (filename.c_str (), std::ios_base::out | std::ios_base::trunc);
+    if (!outFile.is_open ())
+      {
+        NS_LOG_ERROR ("Can't open file " << filename);
+        return;
+      }
+
+  	//outFile << "set xrange [0:100]" << std::endl;
+  	//outFile << "set yrange [0:100]" << std::endl;
+  	outFile << "unset key" << std::endl;
+  	outFile << "set grid" << std::endl;
+
+    uint32_t index = 0;
+    for (BuildingList::Iterator it = BuildingList::Begin (); it != BuildingList::End (); ++it)
+      {
+        ++index;
+        Box box = (*it)->GetBoundaries ();
+        outFile << "set object " << index
+                << " rect from " << box.xMin  << "," << box.yMin
+                << " to "   << box.xMax  << "," << box.yMax
+                //<< " height " << box.zMin << "," << box.zMax
+                << " front fs empty "
+                << std::endl;
+      }
+  }
+
+  void
+  PrintHelper::PrintGnuplottableNodeListToFile (std::string filename)
+  {
+    std::ofstream outFile;
+    outFile.open (filename.c_str (), std::ios_base::out | std::ios_base::trunc);
+    if (!outFile.is_open ())
+      {
+        NS_LOG_ERROR ("Can't open file " << filename);
+        return;
+      }
+    for (NodeList::Iterator it = NodeList::Begin (); it != NodeList::End (); ++it)
+      {
+        Ptr<Node> node = *it;
+        int nDevs = node->GetNDevices ();
+        for (int j = 0; j < nDevs; j++)
+          {
+            Ptr<LteUeNetDevice> uedev = node->GetDevice (j)->GetObject <LteUeNetDevice> ();
+            Ptr<MmWaveUeNetDevice> mmuedev = node->GetDevice (j)->GetObject <MmWaveUeNetDevice> ();
+            Ptr<McUeNetDevice> mcuedev = node->GetDevice (j)->GetObject <McUeNetDevice> ();
+            Ptr<LteEnbNetDevice> enbdev = node->GetDevice (j)->GetObject <LteEnbNetDevice> ();
+            Ptr<MmWaveEnbNetDevice> mmenbdev = node->GetDevice (j)->GetObject <MmWaveEnbNetDevice> ();
+            Ptr<MmWaveIabNetDevice> mmiabdev = node->GetDevice (j)->GetObject <MmWaveIabNetDevice> ();
+            if (uedev)
+              {
+                Vector pos = node->GetObject<MobilityModel> ()->GetPosition ();
+                outFile << "set label \"" << uedev->GetImsi ()
+                        << "\" at "<< pos.x << "," << pos.y << " left font \"Helvetica,8\" textcolor rgb \"black\" front point pt 7 ps 0.3 lc rgb \"black\" offset 0,0"
+                        << std::endl;
+
+                Simulator::Schedule (Seconds (1), &PrintHelper::UpdateGnuplottableNodeListToFile, filename, node);
+              }
+            else if (mmuedev)
+             {
+                Vector pos = node->GetObject<MobilityModel> ()->GetPosition ();
+                outFile << "set label \"" << mmuedev->GetImsi ()
+                        << "\" at "<< pos.x << "," << pos.y << " left font \"Helvetica,8\" textcolor rgb \"black\" front point pt 7 ps 0.3 lc rgb \"black\" offset 0,0"
+                        << std::endl;
+
+                Simulator::Schedule (Seconds (1), &PrintHelper::UpdateGnuplottableNodeListToFile, filename, node);
+              }
+            else if (mcuedev)
+             {
+                Vector pos = node->GetObject<MobilityModel> ()->GetPosition ();
+                outFile << "set label \"" << mcuedev->GetImsi ()
+                        << "\" at "<< pos.x << "," << pos.y << " left font \"Helvetica,8\" textcolor rgb \"black\" front point pt 7 ps 0.3 lc rgb \"black\" offset 0,0"
+                        << std::endl;
+
+                Simulator::Schedule (Seconds (1), &PrintHelper::UpdateGnuplottableNodeListToFile, filename, node);
+              }
+            else if (enbdev)
+              {
+                 Vector pos = node->GetObject<MobilityModel> ()->GetPosition ();
+                 outFile << "set label \"" << enbdev->GetCellId ()
+                         << "\" at "<< pos.x << "," << pos.y << " left font \"Helvetica,8\" textcolor rgb \"red\" front point pt 5 ps 0.8 lc rgb \"red\" offset 0,0"
+                         << std::endl;
+               }
+            else if (mmenbdev)
+              {
+                 Vector pos = node->GetObject<MobilityModel> ()->GetPosition ();
+                 outFile << "set label \"" << mmenbdev->GetCellId ()
+                         << "\" at "<< pos.x << "," << pos.y << " left font \"Helvetica,8\" textcolor rgb \"red\" front point pt 5 ps 0.8 lc rgb \"red\" offset 0,0"
+                         << std::endl;
+               }
+            else if (mmiabdev)
+              {
+                Vector pos = node->GetObject<MobilityModel> ()->GetPosition ();
+                outFile << "set label \"" << mmiabdev->GetCellId ()
+                        << "\" at "<< pos.x << "," << pos.y << " left font \"Helvetica,8\" textcolor rgb \"blue\" front point pt 5 ps 0.8 lc rgb \"blue\" offset 0,0"
+                        << std::endl;
+                Simulator::Schedule (Seconds (1), &PrintHelper::UpdateGnuplottableNodeListToFile, filename, node);
+              }
+          }
+      }
+  }
+
+  void
+  PrintHelper::UpdateGnuplottableNodeListToFile (std::string filename, Ptr<Node> node)
+  {
+    std::ofstream outFile;
+    outFile.open (filename.c_str (), std::ios_base::app);
+    if (!outFile.is_open ())
+      {
+        NS_LOG_ERROR ("Can't open file " << filename);
+        return;
+      }
+    Vector pos = node->GetObject<MobilityModel> ()->GetPosition ();
+
+    Ptr<MmWaveIabNetDevice> mmiabdev = node->GetDevice (0)->GetObject <MmWaveIabNetDevice> ();
+
+    if (mmiabdev) // moving IAB device
+    {
+      outFile << "set label \"" << mmiabdev->GetCellId ()
+              << "\" at "<< pos.x << "," << pos.y << " left font \"Helvetica,8\" textcolor rgb \"blue\" front point pt 5 ps 0.8 lc rgb \"blue\" offset 0,0"
+              << std::endl;
+    }
+    else // moving UE
+    {
+      outFile << "set label \""
+      << "\" at "<< pos.x << "," << pos.y << " left font \"Helvetica,8\" textcolor rgb \"black\" front point pt 1 ps 0.3 lc rgb \"black\" offset 0,0"
+      << std::endl;
+    }
+
+    Simulator::Schedule (Seconds (1), &PrintHelper::UpdateGnuplottableNodeListToFile, filename, node);
+  }
+
+} // end namespace mmwave
+} // end namespace ns3
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/buildings/bindings/modulegen__gcc_ILP32.py iab-psc/src/buildings/bindings/modulegen__gcc_ILP32.py
--- ns3-mmwave-iab/src/buildings/bindings/modulegen__gcc_ILP32.py	2019-02-15 18:12:55.059613983 +0100
+++ iab-psc/src/buildings/bindings/modulegen__gcc_ILP32.py	2019-02-15 18:13:15.447797976 +0100
@@ -32,6 +32,9 @@
     module.add_class('AttributeConstructionList', import_from_module='ns.core')
     ## attribute-construction-list.h (module 'core'): ns3::AttributeConstructionList::Item [struct]
     module.add_class('Item', import_from_module='ns.core', outer_class=root_module['ns3::AttributeConstructionList'])
+    typehandlers.add_type_alias(u'std::list< ns3::AttributeConstructionList::Item > const_iterator', u'ns3::AttributeConstructionList::CIterator')
+    typehandlers.add_type_alias(u'std::list< ns3::AttributeConstructionList::Item > const_iterator*', u'ns3::AttributeConstructionList::CIterator*')
+    typehandlers.add_type_alias(u'std::list< ns3::AttributeConstructionList::Item > const_iterator&', u'ns3::AttributeConstructionList::CIterator&')
     ## box.h (module 'mobility'): ns3::Box [class]
     module.add_class('Box', import_from_module='ns.mobility')
     ## box.h (module 'mobility'): ns3::Box::Side [enumeration]
@@ -42,8 +45,14 @@
     module.add_class('Iterator', import_from_module='ns.network', outer_class=root_module['ns3::Buffer'])
     ## building-container.h (module 'buildings'): ns3::BuildingContainer [class]
     module.add_class('BuildingContainer')
+    typehandlers.add_type_alias(u'std::vector< ns3::Ptr< ns3::Building > > const_iterator', u'ns3::BuildingContainer::Iterator')
+    typehandlers.add_type_alias(u'std::vector< ns3::Ptr< ns3::Building > > const_iterator*', u'ns3::BuildingContainer::Iterator*')
+    typehandlers.add_type_alias(u'std::vector< ns3::Ptr< ns3::Building > > const_iterator&', u'ns3::BuildingContainer::Iterator&')
     ## building-list.h (module 'buildings'): ns3::BuildingList [class]
     module.add_class('BuildingList')
+    typehandlers.add_type_alias(u'std::vector< ns3::Ptr< ns3::Building > > const_iterator', u'ns3::BuildingList::Iterator')
+    typehandlers.add_type_alias(u'std::vector< ns3::Ptr< ns3::Building > > const_iterator*', u'ns3::BuildingList::Iterator*')
+    typehandlers.add_type_alias(u'std::vector< ns3::Ptr< ns3::Building > > const_iterator&', u'ns3::BuildingList::Iterator&')
     ## buildings-helper.h (module 'buildings'): ns3::BuildingsHelper [class]
     module.add_class('BuildingsHelper')
     ## packet.h (module 'network'): ns3::ByteTagIterator [class]
@@ -92,10 +101,20 @@
     module.add_class('Ipv6Prefix', import_from_module='ns.network')
     ## mac48-address.h (module 'network'): ns3::Mac48Address [class]
     module.add_class('Mac48Address', import_from_module='ns.network')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Mac48Address )', u'ns3::Mac48Address::TracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Mac48Address )*', u'ns3::Mac48Address::TracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Mac48Address )&', u'ns3::Mac48Address::TracedCallback&')
     ## mac48-address.h (module 'network'): ns3::Mac48Address [class]
     root_module['ns3::Mac48Address'].implicitly_converts_to(root_module['ns3::Address'])
+    ## mac8-address.h (module 'network'): ns3::Mac8Address [class]
+    module.add_class('Mac8Address', import_from_module='ns.network')
+    ## mac8-address.h (module 'network'): ns3::Mac8Address [class]
+    root_module['ns3::Mac8Address'].implicitly_converts_to(root_module['ns3::Address'])
     ## node-container.h (module 'network'): ns3::NodeContainer [class]
     module.add_class('NodeContainer', import_from_module='ns.network')
+    typehandlers.add_type_alias(u'std::vector< ns3::Ptr< ns3::Node > > const_iterator', u'ns3::NodeContainer::Iterator')
+    typehandlers.add_type_alias(u'std::vector< ns3::Ptr< ns3::Node > > const_iterator*', u'ns3::NodeContainer::Iterator*')
+    typehandlers.add_type_alias(u'std::vector< ns3::Ptr< ns3::Node > > const_iterator&', u'ns3::NodeContainer::Iterator&')
     ## object-base.h (module 'core'): ns3::ObjectBase [class]
     module.add_class('ObjectBase', allow_subclassing=True, import_from_module='ns.core')
     ## object.h (module 'core'): ns3::ObjectDeleter [struct]
@@ -136,6 +155,9 @@
     module.add_class('AttributeInformation', import_from_module='ns.core', outer_class=root_module['ns3::TypeId'])
     ## type-id.h (module 'core'): ns3::TypeId::TraceSourceInformation [struct]
     module.add_class('TraceSourceInformation', import_from_module='ns.core', outer_class=root_module['ns3::TypeId'])
+    typehandlers.add_type_alias(u'uint32_t', u'ns3::TypeId::hash_t')
+    typehandlers.add_type_alias(u'uint32_t*', u'ns3::TypeId::hash_t*')
+    typehandlers.add_type_alias(u'uint32_t&', u'ns3::TypeId::hash_t&')
     ## vector.h (module 'core'): ns3::Vector2D [class]
     module.add_class('Vector2D', import_from_module='ns.core')
     ## vector.h (module 'core'): ns3::Vector3D [class]
@@ -200,6 +222,9 @@
     module.add_class('Time', import_from_module='ns.core')
     ## nstime.h (module 'core'): ns3::Time::Unit [enumeration]
     module.add_enum('Unit', ['Y', 'D', 'H', 'MIN', 'S', 'MS', 'US', 'NS', 'PS', 'FS', 'LAST'], outer_class=root_module['ns3::Time'], import_from_module='ns.core')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Time )', u'ns3::Time::TracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Time )*', u'ns3::Time::TracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Time )&', u'ns3::Time::TracedCallback&')
     ## nstime.h (module 'core'): ns3::Time [class]
     root_module['ns3::Time'].implicitly_converts_to(root_module['ns3::int64x64_t'])
     ## trace-source-accessor.h (module 'core'): ns3::TraceSourceAccessor [class]
@@ -314,10 +339,25 @@
     module.add_class('NetDevice', import_from_module='ns.network', parent=root_module['ns3::Object'])
     ## net-device.h (module 'network'): ns3::NetDevice::PacketType [enumeration]
     module.add_enum('PacketType', ['PACKET_HOST', 'NS3_PACKET_HOST', 'PACKET_BROADCAST', 'NS3_PACKET_BROADCAST', 'PACKET_MULTICAST', 'NS3_PACKET_MULTICAST', 'PACKET_OTHERHOST', 'NS3_PACKET_OTHERHOST'], outer_class=root_module['ns3::NetDevice'], import_from_module='ns.network')
+    typehandlers.add_type_alias(u'void ( * ) (  )', u'ns3::NetDevice::LinkChangeTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) (  )*', u'ns3::NetDevice::LinkChangeTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) (  )&', u'ns3::NetDevice::LinkChangeTracedCallback&')
+    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::NetDevice::ReceiveCallback')
+    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::NetDevice::ReceiveCallback*')
+    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::NetDevice::ReceiveCallback&')
+    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', u'ns3::NetDevice::PromiscReceiveCallback')
+    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::NetDevice::PromiscReceiveCallback*')
+    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::NetDevice::PromiscReceiveCallback&')
     ## nix-vector.h (module 'network'): ns3::NixVector [class]
     module.add_class('NixVector', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::NixVector, ns3::empty, ns3::DefaultDeleter<ns3::NixVector> >'])
     ## node.h (module 'network'): ns3::Node [class]
     module.add_class('Node', import_from_module='ns.network', parent=root_module['ns3::Object'])
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', u'ns3::Node::ProtocolHandler')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::Node::ProtocolHandler*')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::Node::ProtocolHandler&')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::Node::DeviceAdditionListener')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::Node::DeviceAdditionListener*')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::Node::DeviceAdditionListener&')
     ## random-variable-stream.h (module 'core'): ns3::NormalRandomVariable [class]
     module.add_class('NormalRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
     ## object-factory.h (module 'core'): ns3::ObjectFactoryChecker [class]
@@ -326,8 +366,28 @@
     module.add_class('ObjectFactoryValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
     ## oh-buildings-propagation-loss-model.h (module 'buildings'): ns3::OhBuildingsPropagationLossModel [class]
     module.add_class('OhBuildingsPropagationLossModel', parent=root_module['ns3::BuildingsPropagationLossModel'])
+    ## building-position-allocator.h (module 'buildings'): ns3::OutdoorPositionAllocator [class]
+    module.add_class('OutdoorPositionAllocator', parent=root_module['ns3::PositionAllocator'])
     ## packet.h (module 'network'): ns3::Packet [class]
     module.add_class('Packet', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter<ns3::Packet> >'])
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > )', u'ns3::Packet::TracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > )*', u'ns3::Packet::TracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > )&', u'ns3::Packet::TracedCallback&')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Address const & )', u'ns3::Packet::AddressTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Address const & )*', u'ns3::Packet::AddressTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Address const & )&', u'ns3::Packet::AddressTracedCallback&')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > const, ns3::Address const &, ns3::Address const & )', u'ns3::Packet::TwoAddressTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > const, ns3::Address const &, ns3::Address const & )*', u'ns3::Packet::TwoAddressTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > const, ns3::Address const &, ns3::Address const & )&', u'ns3::Packet::TwoAddressTracedCallback&')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Mac48Address )', u'ns3::Packet::Mac48AddressTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Mac48Address )*', u'ns3::Packet::Mac48AddressTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Mac48Address )&', u'ns3::Packet::Mac48AddressTracedCallback&')
+    typehandlers.add_type_alias(u'void ( * ) ( uint32_t, uint32_t )', u'ns3::Packet::SizeTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( uint32_t, uint32_t )*', u'ns3::Packet::SizeTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( uint32_t, uint32_t )&', u'ns3::Packet::SizeTracedCallback&')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, double )', u'ns3::Packet::SinrTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, double )*', u'ns3::Packet::SinrTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, double )&', u'ns3::Packet::SinrTracedCallback&')
     ## random-variable-stream.h (module 'core'): ns3::ParetoRandomVariable [class]
     module.add_class('ParetoRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
     ## nstime.h (module 'core'): ns3::TimeValue [class]
@@ -394,12 +454,12 @@
     
     ## hash-function.h (module 'core'): ns3::Hash::Implementation [class]
     module.add_class('Implementation', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::Hash::Implementation, ns3::empty, ns3::DefaultDeleter<ns3::Hash::Implementation> >'])
-    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, size_t const )', u'ns3::Hash::Hash32Function_ptr')
-    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, size_t const )*', u'ns3::Hash::Hash32Function_ptr*')
-    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, size_t const )&', u'ns3::Hash::Hash32Function_ptr&')
-    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, size_t const )', u'ns3::Hash::Hash64Function_ptr')
-    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, size_t const )*', u'ns3::Hash::Hash64Function_ptr*')
-    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, size_t const )&', u'ns3::Hash::Hash64Function_ptr&')
+    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, std::size_t const )', u'ns3::Hash::Hash32Function_ptr')
+    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, std::size_t const )*', u'ns3::Hash::Hash32Function_ptr*')
+    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, std::size_t const )&', u'ns3::Hash::Hash32Function_ptr&')
+    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, std::size_t const )', u'ns3::Hash::Hash64Function_ptr')
+    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, std::size_t const )*', u'ns3::Hash::Hash64Function_ptr*')
+    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, std::size_t const )&', u'ns3::Hash::Hash64Function_ptr&')
     
     ## Register a nested module for the namespace Function
     
@@ -457,6 +517,7 @@
     register_Ns3Ipv6Address_methods(root_module, root_module['ns3::Ipv6Address'])
     register_Ns3Ipv6Prefix_methods(root_module, root_module['ns3::Ipv6Prefix'])
     register_Ns3Mac48Address_methods(root_module, root_module['ns3::Mac48Address'])
+    register_Ns3Mac8Address_methods(root_module, root_module['ns3::Mac8Address'])
     register_Ns3NodeContainer_methods(root_module, root_module['ns3::NodeContainer'])
     register_Ns3ObjectBase_methods(root_module, root_module['ns3::ObjectBase'])
     register_Ns3ObjectDeleter_methods(root_module, root_module['ns3::ObjectDeleter'])
@@ -563,6 +624,7 @@
     register_Ns3ObjectFactoryChecker_methods(root_module, root_module['ns3::ObjectFactoryChecker'])
     register_Ns3ObjectFactoryValue_methods(root_module, root_module['ns3::ObjectFactoryValue'])
     register_Ns3OhBuildingsPropagationLossModel_methods(root_module, root_module['ns3::OhBuildingsPropagationLossModel'])
+    register_Ns3OutdoorPositionAllocator_methods(root_module, root_module['ns3::OutdoorPositionAllocator'])
     register_Ns3Packet_methods(root_module, root_module['ns3::Packet'])
     register_Ns3ParetoRandomVariable_methods(root_module, root_module['ns3::ParetoRandomVariable'])
     register_Ns3TimeValue_methods(root_module, root_module['ns3::TimeValue'])
@@ -1362,18 +1424,18 @@
     cls.add_constructor([])
     ## hash.h (module 'core'): ns3::Hasher::Hasher(ns3::Ptr<ns3::Hash::Implementation> hp) [constructor]
     cls.add_constructor([param('ns3::Ptr< ns3::Hash::Implementation >', 'hp')])
-    ## hash.h (module 'core'): uint32_t ns3::Hasher::GetHash32(char const * buffer, size_t const size) [member function]
+    ## hash.h (module 'core'): uint32_t ns3::Hasher::GetHash32(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')])
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')])
     ## hash.h (module 'core'): uint32_t ns3::Hasher::GetHash32(std::string const s) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
                    [param('std::string const', 's')])
-    ## hash.h (module 'core'): uint64_t ns3::Hasher::GetHash64(char const * buffer, size_t const size) [member function]
+    ## hash.h (module 'core'): uint64_t ns3::Hasher::GetHash64(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash64', 
                    'uint64_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')])
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')])
     ## hash.h (module 'core'): uint64_t ns3::Hasher::GetHash64(std::string const s) [member function]
     cls.add_method('GetHash64', 
                    'uint64_t', 
@@ -1643,7 +1705,7 @@
     cls.add_method('IsAllHostsMulticast', 
                    'bool', 
                    [], 
-                   is_const=True)
+                   deprecated=True, is_const=True)
     ## ipv6-address.h (module 'network'): bool ns3::Ipv6Address::IsAllNodesMulticast() const [member function]
     cls.add_method('IsAllNodesMulticast', 
                    'bool', 
@@ -1719,6 +1781,11 @@
                    'ns3::Ipv6Address', 
                    [param('ns3::Mac64Address', 'addr'), param('ns3::Ipv6Address', 'prefix')], 
                    is_static=True)
+    ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::MakeAutoconfiguredAddress(ns3::Mac8Address addr, ns3::Ipv6Address prefix) [member function]
+    cls.add_method('MakeAutoconfiguredAddress', 
+                   'ns3::Ipv6Address', 
+                   [param('ns3::Mac8Address', 'addr'), param('ns3::Ipv6Address', 'prefix')], 
+                   is_static=True)
     ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::MakeAutoconfiguredLinkLocalAddress(ns3::Mac16Address mac) [member function]
     cls.add_method('MakeAutoconfiguredLinkLocalAddress', 
                    'ns3::Ipv6Address', 
@@ -1734,6 +1801,11 @@
                    'ns3::Ipv6Address', 
                    [param('ns3::Mac64Address', 'mac')], 
                    is_static=True)
+    ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::MakeAutoconfiguredLinkLocalAddress(ns3::Mac8Address mac) [member function]
+    cls.add_method('MakeAutoconfiguredLinkLocalAddress', 
+                   'ns3::Ipv6Address', 
+                   [param('ns3::Mac8Address', 'mac')], 
+                   is_static=True)
     ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::MakeIpv4MappedAddress(ns3::Ipv4Address addr) [member function]
     cls.add_method('MakeIpv4MappedAddress', 
                    'ns3::Ipv6Address', 
@@ -1894,6 +1966,48 @@
                    is_static=True)
     return
 
+def register_Ns3Mac8Address_methods(root_module, cls):
+    cls.add_binary_comparison_operator('<')
+    cls.add_binary_comparison_operator('==')
+    cls.add_binary_comparison_operator('!=')
+    cls.add_output_stream_operator()
+    ## mac8-address.h (module 'network'): ns3::Mac8Address::Mac8Address(ns3::Mac8Address const & arg0) [constructor]
+    cls.add_constructor([param('ns3::Mac8Address const &', 'arg0')])
+    ## mac8-address.h (module 'network'): ns3::Mac8Address::Mac8Address() [constructor]
+    cls.add_constructor([])
+    ## mac8-address.h (module 'network'): ns3::Mac8Address::Mac8Address(uint8_t addr) [constructor]
+    cls.add_constructor([param('uint8_t', 'addr')])
+    ## mac8-address.h (module 'network'): static ns3::Mac8Address ns3::Mac8Address::Allocate() [member function]
+    cls.add_method('Allocate', 
+                   'ns3::Mac8Address', 
+                   [], 
+                   is_static=True)
+    ## mac8-address.h (module 'network'): static ns3::Mac8Address ns3::Mac8Address::ConvertFrom(ns3::Address const & address) [member function]
+    cls.add_method('ConvertFrom', 
+                   'ns3::Mac8Address', 
+                   [param('ns3::Address const &', 'address')], 
+                   is_static=True)
+    ## mac8-address.h (module 'network'): void ns3::Mac8Address::CopyFrom(uint8_t const * pBuffer) [member function]
+    cls.add_method('CopyFrom', 
+                   'void', 
+                   [param('uint8_t const *', 'pBuffer')])
+    ## mac8-address.h (module 'network'): void ns3::Mac8Address::CopyTo(uint8_t * pBuffer) const [member function]
+    cls.add_method('CopyTo', 
+                   'void', 
+                   [param('uint8_t *', 'pBuffer')], 
+                   is_const=True)
+    ## mac8-address.h (module 'network'): static ns3::Mac8Address ns3::Mac8Address::GetBroadcast() [member function]
+    cls.add_method('GetBroadcast', 
+                   'ns3::Mac8Address', 
+                   [], 
+                   is_static=True)
+    ## mac8-address.h (module 'network'): static bool ns3::Mac8Address::IsMatchingType(ns3::Address const & address) [member function]
+    cls.add_method('IsMatchingType', 
+                   'bool', 
+                   [param('ns3::Address const &', 'address')], 
+                   is_static=True)
+    return
+
 def register_Ns3NodeContainer_methods(root_module, cls):
     ## node-container.h (module 'network'): ns3::NodeContainer::NodeContainer(ns3::NodeContainer const & arg0) [constructor]
     cls.add_constructor([param('ns3::NodeContainer const &', 'arg0')])
@@ -1928,6 +2042,11 @@
                    'ns3::NodeContainer::Iterator', 
                    [], 
                    is_const=True)
+    ## node-container.h (module 'network'): bool ns3::NodeContainer::Contains(uint32_t id) const [member function]
+    cls.add_method('Contains', 
+                   'bool', 
+                   [param('uint32_t', 'id')], 
+                   is_const=True)
     ## node-container.h (module 'network'): void ns3::NodeContainer::Create(uint32_t n) [member function]
     cls.add_method('Create', 
                    'void', 
@@ -2394,24 +2513,25 @@
     ## type-id.h (module 'core'): ns3::TypeId ns3::TypeId::AddTraceSource(std::string name, std::string help, ns3::Ptr<const ns3::TraceSourceAccessor> accessor) [member function]
     cls.add_method('AddTraceSource', 
                    'ns3::TypeId', 
-                   [param('std::string', 'name'), param('std::string', 'help'), param('ns3::Ptr< ns3::TraceSourceAccessor const >', 'accessor')])
+                   [param('std::string', 'name'), param('std::string', 'help'), param('ns3::Ptr< ns3::TraceSourceAccessor const >', 'accessor')], 
+                   deprecated=True)
     ## type-id.h (module 'core'): ns3::TypeId ns3::TypeId::AddTraceSource(std::string name, std::string help, ns3::Ptr<const ns3::TraceSourceAccessor> accessor, std::string callback, ns3::TypeId::SupportLevel supportLevel=::ns3::TypeId::SupportLevel::SUPPORTED, std::string const & supportMsg="") [member function]
     cls.add_method('AddTraceSource', 
                    'ns3::TypeId', 
                    [param('std::string', 'name'), param('std::string', 'help'), param('ns3::Ptr< ns3::TraceSourceAccessor const >', 'accessor'), param('std::string', 'callback'), param('ns3::TypeId::SupportLevel', 'supportLevel', default_value='::ns3::TypeId::SupportLevel::SUPPORTED'), param('std::string const &', 'supportMsg', default_value='""')])
-    ## type-id.h (module 'core'): ns3::TypeId::AttributeInformation ns3::TypeId::GetAttribute(uint32_t i) const [member function]
+    ## type-id.h (module 'core'): ns3::TypeId::AttributeInformation ns3::TypeId::GetAttribute(std::size_t i) const [member function]
     cls.add_method('GetAttribute', 
                    'ns3::TypeId::AttributeInformation', 
-                   [param('uint32_t', 'i')], 
+                   [param('std::size_t', 'i')], 
                    is_const=True)
-    ## type-id.h (module 'core'): std::string ns3::TypeId::GetAttributeFullName(uint32_t i) const [member function]
+    ## type-id.h (module 'core'): std::string ns3::TypeId::GetAttributeFullName(std::size_t i) const [member function]
     cls.add_method('GetAttributeFullName', 
                    'std::string', 
-                   [param('uint32_t', 'i')], 
+                   [param('std::size_t', 'i')], 
                    is_const=True)
-    ## type-id.h (module 'core'): uint32_t ns3::TypeId::GetAttributeN() const [member function]
+    ## type-id.h (module 'core'): std::size_t ns3::TypeId::GetAttributeN() const [member function]
     cls.add_method('GetAttributeN', 
-                   'uint32_t', 
+                   'std::size_t', 
                    [], 
                    is_const=True)
     ## type-id.h (module 'core'): ns3::Callback<ns3::ObjectBase *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> ns3::TypeId::GetConstructor() const [member function]
@@ -2439,14 +2559,14 @@
                    'ns3::TypeId', 
                    [], 
                    is_const=True)
-    ## type-id.h (module 'core'): static ns3::TypeId ns3::TypeId::GetRegistered(uint32_t i) [member function]
+    ## type-id.h (module 'core'): static ns3::TypeId ns3::TypeId::GetRegistered(uint16_t i) [member function]
     cls.add_method('GetRegistered', 
                    'ns3::TypeId', 
-                   [param('uint32_t', 'i')], 
+                   [param('uint16_t', 'i')], 
                    is_static=True)
-    ## type-id.h (module 'core'): static uint32_t ns3::TypeId::GetRegisteredN() [member function]
+    ## type-id.h (module 'core'): static uint16_t ns3::TypeId::GetRegisteredN() [member function]
     cls.add_method('GetRegisteredN', 
-                   'uint32_t', 
+                   'uint16_t', 
                    [], 
                    is_static=True)
     ## type-id.h (module 'core'): std::size_t ns3::TypeId::GetSize() const [member function]
@@ -2454,14 +2574,14 @@
                    'std::size_t', 
                    [], 
                    is_const=True)
-    ## type-id.h (module 'core'): ns3::TypeId::TraceSourceInformation ns3::TypeId::GetTraceSource(uint32_t i) const [member function]
+    ## type-id.h (module 'core'): ns3::TypeId::TraceSourceInformation ns3::TypeId::GetTraceSource(std::size_t i) const [member function]
     cls.add_method('GetTraceSource', 
                    'ns3::TypeId::TraceSourceInformation', 
-                   [param('uint32_t', 'i')], 
+                   [param('std::size_t', 'i')], 
                    is_const=True)
-    ## type-id.h (module 'core'): uint32_t ns3::TypeId::GetTraceSourceN() const [member function]
+    ## type-id.h (module 'core'): std::size_t ns3::TypeId::GetTraceSourceN() const [member function]
     cls.add_method('GetTraceSourceN', 
-                   'uint32_t', 
+                   'std::size_t', 
                    [], 
                    is_const=True)
     ## type-id.h (module 'core'): uint16_t ns3::TypeId::GetUid() const [member function]
@@ -2523,10 +2643,10 @@
                    'bool', 
                    [], 
                    is_const=True)
-    ## type-id.h (module 'core'): bool ns3::TypeId::SetAttributeInitialValue(uint32_t i, ns3::Ptr<const ns3::AttributeValue> initialValue) [member function]
+    ## type-id.h (module 'core'): bool ns3::TypeId::SetAttributeInitialValue(std::size_t i, ns3::Ptr<const ns3::AttributeValue> initialValue) [member function]
     cls.add_method('SetAttributeInitialValue', 
                    'bool', 
-                   [param('uint32_t', 'i'), param('ns3::Ptr< ns3::AttributeValue const >', 'initialValue')])
+                   [param('std::size_t', 'i'), param('ns3::Ptr< ns3::AttributeValue const >', 'initialValue')])
     ## type-id.h (module 'core'): ns3::TypeId ns3::TypeId::SetGroupName(std::string groupName) [member function]
     cls.add_method('SetGroupName', 
                    'ns3::TypeId', 
@@ -2718,6 +2838,11 @@
                    'uint32_t', 
                    [param('ns3::Buffer::Iterator', 'start')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## chunk.h (module 'network'): uint32_t ns3::Chunk::Deserialize(ns3::Buffer::Iterator start, ns3::Buffer::Iterator end) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start'), param('ns3::Buffer::Iterator', 'end')], 
+                   is_virtual=True)
     ## chunk.h (module 'network'): static ns3::TypeId ns3::Chunk::GetTypeId() [member function]
     cls.add_method('GetTypeId', 
                    'ns3::TypeId', 
@@ -3498,6 +3623,11 @@
                    'uint32_t', 
                    [param('ns3::Buffer::Iterator', 'end')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## trailer.h (module 'network'): uint32_t ns3::Trailer::Deserialize(ns3::Buffer::Iterator start, ns3::Buffer::Iterator end) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start'), param('ns3::Buffer::Iterator', 'end')], 
+                   is_virtual=True)
     ## trailer.h (module 'network'): uint32_t ns3::Trailer::GetSerializedSize() const [member function]
     cls.add_method('GetSerializedSize', 
                    'uint32_t', 
@@ -4212,10 +4342,10 @@
                    is_static=True)
     ## random-variable-stream.h (module 'core'): ns3::DeterministicRandomVariable::DeterministicRandomVariable() [constructor]
     cls.add_constructor([])
-    ## random-variable-stream.h (module 'core'): void ns3::DeterministicRandomVariable::SetValueArray(double * values, uint64_t length) [member function]
+    ## random-variable-stream.h (module 'core'): void ns3::DeterministicRandomVariable::SetValueArray(double * values, std::size_t length) [member function]
     cls.add_method('SetValueArray', 
                    'void', 
-                   [param('double *', 'values'), param('uint64_t', 'length')])
+                   [param('double *', 'values'), param('std::size_t', 'length')])
     ## random-variable-stream.h (module 'core'): double ns3::DeterministicRandomVariable::GetValue() [member function]
     cls.add_method('GetValue', 
                    'double', 
@@ -5472,6 +5602,40 @@
                    is_const=True, is_virtual=True)
     return
 
+def register_Ns3OutdoorPositionAllocator_methods(root_module, cls):
+    ## building-position-allocator.h (module 'buildings'): ns3::OutdoorPositionAllocator::OutdoorPositionAllocator(ns3::OutdoorPositionAllocator const & arg0) [constructor]
+    cls.add_constructor([param('ns3::OutdoorPositionAllocator const &', 'arg0')])
+    ## building-position-allocator.h (module 'buildings'): ns3::OutdoorPositionAllocator::OutdoorPositionAllocator() [constructor]
+    cls.add_constructor([])
+    ## building-position-allocator.h (module 'buildings'): int64_t ns3::OutdoorPositionAllocator::AssignStreams(int64_t stream) [member function]
+    cls.add_method('AssignStreams', 
+                   'int64_t', 
+                   [param('int64_t', 'stream')], 
+                   is_virtual=True)
+    ## building-position-allocator.h (module 'buildings'): ns3::Vector ns3::OutdoorPositionAllocator::GetNext() const [member function]
+    cls.add_method('GetNext', 
+                   'ns3::Vector', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## building-position-allocator.h (module 'buildings'): static ns3::TypeId ns3::OutdoorPositionAllocator::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## building-position-allocator.h (module 'buildings'): void ns3::OutdoorPositionAllocator::SetX(ns3::Ptr<ns3::RandomVariableStream> x) [member function]
+    cls.add_method('SetX', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::RandomVariableStream >', 'x')])
+    ## building-position-allocator.h (module 'buildings'): void ns3::OutdoorPositionAllocator::SetY(ns3::Ptr<ns3::RandomVariableStream> y) [member function]
+    cls.add_method('SetY', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::RandomVariableStream >', 'y')])
+    ## building-position-allocator.h (module 'buildings'): void ns3::OutdoorPositionAllocator::SetZ(ns3::Ptr<ns3::RandomVariableStream> z) [member function]
+    cls.add_method('SetZ', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::RandomVariableStream >', 'z')])
+    return
+
 def register_Ns3Packet_methods(root_module, cls):
     cls.add_output_stream_operator()
     ## packet.h (module 'network'): ns3::Packet::Packet() [constructor]
@@ -5585,6 +5749,11 @@
                    'uint32_t', 
                    [param('ns3::Header &', 'header')], 
                    is_const=True)
+    ## packet.h (module 'network'): uint32_t ns3::Packet::PeekHeader(ns3::Header & header, uint32_t size) const [member function]
+    cls.add_method('PeekHeader', 
+                   'uint32_t', 
+                   [param('ns3::Header &', 'header'), param('uint32_t', 'size')], 
+                   is_const=True)
     ## packet.h (module 'network'): bool ns3::Packet::PeekPacketTag(ns3::Tag & tag) const [member function]
     cls.add_method('PeekPacketTag', 
                    'bool', 
@@ -5629,6 +5798,10 @@
     cls.add_method('RemoveHeader', 
                    'uint32_t', 
                    [param('ns3::Header &', 'header')])
+    ## packet.h (module 'network'): uint32_t ns3::Packet::RemoveHeader(ns3::Header & header, uint32_t size) [member function]
+    cls.add_method('RemoveHeader', 
+                   'uint32_t', 
+                   [param('ns3::Header &', 'header'), param('uint32_t', 'size')])
     ## packet.h (module 'network'): bool ns3::Packet::RemovePacketTag(ns3::Tag & tag) [member function]
     cls.add_method('RemovePacketTag', 
                    'bool', 
@@ -5669,7 +5842,7 @@
     cls.add_method('GetMean', 
                    'double', 
                    [], 
-                   is_const=True)
+                   deprecated=True, is_const=True)
     ## random-variable-stream.h (module 'core'): double ns3::ParetoRandomVariable::GetScale() const [member function]
     cls.add_method('GetScale', 
                    'double', 
@@ -5969,15 +6142,15 @@
     cls.add_constructor([param('ns3::Hash::Implementation const &', 'arg0')])
     ## hash-function.h (module 'core'): ns3::Hash::Implementation::Implementation() [constructor]
     cls.add_constructor([])
-    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Implementation::GetHash32(char const * buffer, size_t const size) [member function]
+    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Implementation::GetHash32(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_pure_virtual=True, is_virtual=True)
-    ## hash-function.h (module 'core'): uint64_t ns3::Hash::Implementation::GetHash64(char const * buffer, size_t const size) [member function]
+    ## hash-function.h (module 'core'): uint64_t ns3::Hash::Implementation::GetHash64(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash64', 
                    'uint64_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_virtual=True)
     ## hash-function.h (module 'core'): void ns3::Hash::Implementation::clear() [member function]
     cls.add_method('clear', 
@@ -6013,10 +6186,10 @@
     cls.add_constructor([param('ns3::Hash::Function::Hash32 const &', 'arg0')])
     ## hash-function.h (module 'core'): ns3::Hash::Function::Hash32::Hash32(ns3::Hash::Hash32Function_ptr hp) [constructor]
     cls.add_constructor([param('ns3::Hash::Hash32Function_ptr', 'hp')])
-    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Function::Hash32::GetHash32(char const * buffer, size_t const size) [member function]
+    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Function::Hash32::GetHash32(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_virtual=True)
     ## hash-function.h (module 'core'): void ns3::Hash::Function::Hash32::clear() [member function]
     cls.add_method('clear', 
@@ -6030,15 +6203,15 @@
     cls.add_constructor([param('ns3::Hash::Function::Hash64 const &', 'arg0')])
     ## hash-function.h (module 'core'): ns3::Hash::Function::Hash64::Hash64(ns3::Hash::Hash64Function_ptr hp) [constructor]
     cls.add_constructor([param('ns3::Hash::Hash64Function_ptr', 'hp')])
-    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Function::Hash64::GetHash32(char const * buffer, size_t const size) [member function]
+    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Function::Hash64::GetHash32(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_virtual=True)
-    ## hash-function.h (module 'core'): uint64_t ns3::Hash::Function::Hash64::GetHash64(char const * buffer, size_t const size) [member function]
+    ## hash-function.h (module 'core'): uint64_t ns3::Hash::Function::Hash64::GetHash64(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash64', 
                    'uint64_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_virtual=True)
     ## hash-function.h (module 'core'): void ns3::Hash::Function::Hash64::clear() [member function]
     cls.add_method('clear', 
@@ -6052,15 +6225,15 @@
     cls.add_constructor([param('ns3::Hash::Function::Murmur3 const &', 'arg0')])
     ## hash-murmur3.h (module 'core'): ns3::Hash::Function::Murmur3::Murmur3() [constructor]
     cls.add_constructor([])
-    ## hash-murmur3.h (module 'core'): uint32_t ns3::Hash::Function::Murmur3::GetHash32(char const * buffer, size_t const size) [member function]
+    ## hash-murmur3.h (module 'core'): uint32_t ns3::Hash::Function::Murmur3::GetHash32(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_virtual=True)
-    ## hash-murmur3.h (module 'core'): uint64_t ns3::Hash::Function::Murmur3::GetHash64(char const * buffer, size_t const size) [member function]
+    ## hash-murmur3.h (module 'core'): uint64_t ns3::Hash::Function::Murmur3::GetHash64(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash64', 
                    'uint64_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_virtual=True)
     ## hash-murmur3.h (module 'core'): void ns3::Hash::Function::Murmur3::clear() [member function]
     cls.add_method('clear', 
@@ -6071,16 +6244,16 @@
 
 def register_functions(root_module):
     module = root_module
-    register_functions_ns3_FatalImpl(module.get_submodule('FatalImpl'), root_module)
-    register_functions_ns3_Hash(module.get_submodule('Hash'), root_module)
-    register_functions_ns3_TracedValueCallback(module.get_submodule('TracedValueCallback'), root_module)
+    register_functions_ns3_FatalImpl(module.add_cpp_namespace('FatalImpl'), root_module)
+    register_functions_ns3_Hash(module.add_cpp_namespace('Hash'), root_module)
+    register_functions_ns3_TracedValueCallback(module.add_cpp_namespace('TracedValueCallback'), root_module)
     return
 
 def register_functions_ns3_FatalImpl(module, root_module):
     return
 
 def register_functions_ns3_Hash(module, root_module):
-    register_functions_ns3_Hash_Function(module.get_submodule('Function'), root_module)
+    register_functions_ns3_Hash_Function(module.add_cpp_namespace('Function'), root_module)
     return
 
 def register_functions_ns3_Hash_Function(module, root_module):
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/buildings/bindings/modulegen__gcc_LP64.py iab-psc/src/buildings/bindings/modulegen__gcc_LP64.py
--- ns3-mmwave-iab/src/buildings/bindings/modulegen__gcc_LP64.py	2019-02-15 18:12:55.059613983 +0100
+++ iab-psc/src/buildings/bindings/modulegen__gcc_LP64.py	2019-02-15 18:13:15.451798012 +0100
@@ -32,6 +32,9 @@
     module.add_class('AttributeConstructionList', import_from_module='ns.core')
     ## attribute-construction-list.h (module 'core'): ns3::AttributeConstructionList::Item [struct]
     module.add_class('Item', import_from_module='ns.core', outer_class=root_module['ns3::AttributeConstructionList'])
+    typehandlers.add_type_alias(u'std::list< ns3::AttributeConstructionList::Item > const_iterator', u'ns3::AttributeConstructionList::CIterator')
+    typehandlers.add_type_alias(u'std::list< ns3::AttributeConstructionList::Item > const_iterator*', u'ns3::AttributeConstructionList::CIterator*')
+    typehandlers.add_type_alias(u'std::list< ns3::AttributeConstructionList::Item > const_iterator&', u'ns3::AttributeConstructionList::CIterator&')
     ## box.h (module 'mobility'): ns3::Box [class]
     module.add_class('Box', import_from_module='ns.mobility')
     ## box.h (module 'mobility'): ns3::Box::Side [enumeration]
@@ -42,8 +45,14 @@
     module.add_class('Iterator', import_from_module='ns.network', outer_class=root_module['ns3::Buffer'])
     ## building-container.h (module 'buildings'): ns3::BuildingContainer [class]
     module.add_class('BuildingContainer')
+    typehandlers.add_type_alias(u'std::vector< ns3::Ptr< ns3::Building > > const_iterator', u'ns3::BuildingContainer::Iterator')
+    typehandlers.add_type_alias(u'std::vector< ns3::Ptr< ns3::Building > > const_iterator*', u'ns3::BuildingContainer::Iterator*')
+    typehandlers.add_type_alias(u'std::vector< ns3::Ptr< ns3::Building > > const_iterator&', u'ns3::BuildingContainer::Iterator&')
     ## building-list.h (module 'buildings'): ns3::BuildingList [class]
     module.add_class('BuildingList')
+    typehandlers.add_type_alias(u'std::vector< ns3::Ptr< ns3::Building > > const_iterator', u'ns3::BuildingList::Iterator')
+    typehandlers.add_type_alias(u'std::vector< ns3::Ptr< ns3::Building > > const_iterator*', u'ns3::BuildingList::Iterator*')
+    typehandlers.add_type_alias(u'std::vector< ns3::Ptr< ns3::Building > > const_iterator&', u'ns3::BuildingList::Iterator&')
     ## buildings-helper.h (module 'buildings'): ns3::BuildingsHelper [class]
     module.add_class('BuildingsHelper')
     ## packet.h (module 'network'): ns3::ByteTagIterator [class]
@@ -92,10 +101,20 @@
     module.add_class('Ipv6Prefix', import_from_module='ns.network')
     ## mac48-address.h (module 'network'): ns3::Mac48Address [class]
     module.add_class('Mac48Address', import_from_module='ns.network')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Mac48Address )', u'ns3::Mac48Address::TracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Mac48Address )*', u'ns3::Mac48Address::TracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Mac48Address )&', u'ns3::Mac48Address::TracedCallback&')
     ## mac48-address.h (module 'network'): ns3::Mac48Address [class]
     root_module['ns3::Mac48Address'].implicitly_converts_to(root_module['ns3::Address'])
+    ## mac8-address.h (module 'network'): ns3::Mac8Address [class]
+    module.add_class('Mac8Address', import_from_module='ns.network')
+    ## mac8-address.h (module 'network'): ns3::Mac8Address [class]
+    root_module['ns3::Mac8Address'].implicitly_converts_to(root_module['ns3::Address'])
     ## node-container.h (module 'network'): ns3::NodeContainer [class]
     module.add_class('NodeContainer', import_from_module='ns.network')
+    typehandlers.add_type_alias(u'std::vector< ns3::Ptr< ns3::Node > > const_iterator', u'ns3::NodeContainer::Iterator')
+    typehandlers.add_type_alias(u'std::vector< ns3::Ptr< ns3::Node > > const_iterator*', u'ns3::NodeContainer::Iterator*')
+    typehandlers.add_type_alias(u'std::vector< ns3::Ptr< ns3::Node > > const_iterator&', u'ns3::NodeContainer::Iterator&')
     ## object-base.h (module 'core'): ns3::ObjectBase [class]
     module.add_class('ObjectBase', allow_subclassing=True, import_from_module='ns.core')
     ## object.h (module 'core'): ns3::ObjectDeleter [struct]
@@ -136,6 +155,9 @@
     module.add_class('AttributeInformation', import_from_module='ns.core', outer_class=root_module['ns3::TypeId'])
     ## type-id.h (module 'core'): ns3::TypeId::TraceSourceInformation [struct]
     module.add_class('TraceSourceInformation', import_from_module='ns.core', outer_class=root_module['ns3::TypeId'])
+    typehandlers.add_type_alias(u'uint32_t', u'ns3::TypeId::hash_t')
+    typehandlers.add_type_alias(u'uint32_t*', u'ns3::TypeId::hash_t*')
+    typehandlers.add_type_alias(u'uint32_t&', u'ns3::TypeId::hash_t&')
     ## vector.h (module 'core'): ns3::Vector2D [class]
     module.add_class('Vector2D', import_from_module='ns.core')
     ## vector.h (module 'core'): ns3::Vector3D [class]
@@ -200,6 +222,9 @@
     module.add_class('Time', import_from_module='ns.core')
     ## nstime.h (module 'core'): ns3::Time::Unit [enumeration]
     module.add_enum('Unit', ['Y', 'D', 'H', 'MIN', 'S', 'MS', 'US', 'NS', 'PS', 'FS', 'LAST'], outer_class=root_module['ns3::Time'], import_from_module='ns.core')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Time )', u'ns3::Time::TracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Time )*', u'ns3::Time::TracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Time )&', u'ns3::Time::TracedCallback&')
     ## nstime.h (module 'core'): ns3::Time [class]
     root_module['ns3::Time'].implicitly_converts_to(root_module['ns3::int64x64_t'])
     ## trace-source-accessor.h (module 'core'): ns3::TraceSourceAccessor [class]
@@ -314,10 +339,25 @@
     module.add_class('NetDevice', import_from_module='ns.network', parent=root_module['ns3::Object'])
     ## net-device.h (module 'network'): ns3::NetDevice::PacketType [enumeration]
     module.add_enum('PacketType', ['PACKET_HOST', 'NS3_PACKET_HOST', 'PACKET_BROADCAST', 'NS3_PACKET_BROADCAST', 'PACKET_MULTICAST', 'NS3_PACKET_MULTICAST', 'PACKET_OTHERHOST', 'NS3_PACKET_OTHERHOST'], outer_class=root_module['ns3::NetDevice'], import_from_module='ns.network')
+    typehandlers.add_type_alias(u'void ( * ) (  )', u'ns3::NetDevice::LinkChangeTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) (  )*', u'ns3::NetDevice::LinkChangeTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) (  )&', u'ns3::NetDevice::LinkChangeTracedCallback&')
+    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::NetDevice::ReceiveCallback')
+    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::NetDevice::ReceiveCallback*')
+    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::NetDevice::ReceiveCallback&')
+    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', u'ns3::NetDevice::PromiscReceiveCallback')
+    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::NetDevice::PromiscReceiveCallback*')
+    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::NetDevice::PromiscReceiveCallback&')
     ## nix-vector.h (module 'network'): ns3::NixVector [class]
     module.add_class('NixVector', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::NixVector, ns3::empty, ns3::DefaultDeleter<ns3::NixVector> >'])
     ## node.h (module 'network'): ns3::Node [class]
     module.add_class('Node', import_from_module='ns.network', parent=root_module['ns3::Object'])
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', u'ns3::Node::ProtocolHandler')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::Node::ProtocolHandler*')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::Node::ProtocolHandler&')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::Node::DeviceAdditionListener')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::Node::DeviceAdditionListener*')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::Node::DeviceAdditionListener&')
     ## random-variable-stream.h (module 'core'): ns3::NormalRandomVariable [class]
     module.add_class('NormalRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
     ## object-factory.h (module 'core'): ns3::ObjectFactoryChecker [class]
@@ -326,8 +366,28 @@
     module.add_class('ObjectFactoryValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
     ## oh-buildings-propagation-loss-model.h (module 'buildings'): ns3::OhBuildingsPropagationLossModel [class]
     module.add_class('OhBuildingsPropagationLossModel', parent=root_module['ns3::BuildingsPropagationLossModel'])
+    ## building-position-allocator.h (module 'buildings'): ns3::OutdoorPositionAllocator [class]
+    module.add_class('OutdoorPositionAllocator', parent=root_module['ns3::PositionAllocator'])
     ## packet.h (module 'network'): ns3::Packet [class]
     module.add_class('Packet', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter<ns3::Packet> >'])
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > )', u'ns3::Packet::TracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > )*', u'ns3::Packet::TracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > )&', u'ns3::Packet::TracedCallback&')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Address const & )', u'ns3::Packet::AddressTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Address const & )*', u'ns3::Packet::AddressTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Address const & )&', u'ns3::Packet::AddressTracedCallback&')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > const, ns3::Address const &, ns3::Address const & )', u'ns3::Packet::TwoAddressTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > const, ns3::Address const &, ns3::Address const & )*', u'ns3::Packet::TwoAddressTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > const, ns3::Address const &, ns3::Address const & )&', u'ns3::Packet::TwoAddressTracedCallback&')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Mac48Address )', u'ns3::Packet::Mac48AddressTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Mac48Address )*', u'ns3::Packet::Mac48AddressTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Mac48Address )&', u'ns3::Packet::Mac48AddressTracedCallback&')
+    typehandlers.add_type_alias(u'void ( * ) ( uint32_t, uint32_t )', u'ns3::Packet::SizeTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( uint32_t, uint32_t )*', u'ns3::Packet::SizeTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( uint32_t, uint32_t )&', u'ns3::Packet::SizeTracedCallback&')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, double )', u'ns3::Packet::SinrTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, double )*', u'ns3::Packet::SinrTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, double )&', u'ns3::Packet::SinrTracedCallback&')
     ## random-variable-stream.h (module 'core'): ns3::ParetoRandomVariable [class]
     module.add_class('ParetoRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
     ## nstime.h (module 'core'): ns3::TimeValue [class]
@@ -394,12 +454,12 @@
     
     ## hash-function.h (module 'core'): ns3::Hash::Implementation [class]
     module.add_class('Implementation', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::Hash::Implementation, ns3::empty, ns3::DefaultDeleter<ns3::Hash::Implementation> >'])
-    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, size_t const )', u'ns3::Hash::Hash32Function_ptr')
-    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, size_t const )*', u'ns3::Hash::Hash32Function_ptr*')
-    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, size_t const )&', u'ns3::Hash::Hash32Function_ptr&')
-    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, size_t const )', u'ns3::Hash::Hash64Function_ptr')
-    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, size_t const )*', u'ns3::Hash::Hash64Function_ptr*')
-    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, size_t const )&', u'ns3::Hash::Hash64Function_ptr&')
+    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, std::size_t const )', u'ns3::Hash::Hash32Function_ptr')
+    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, std::size_t const )*', u'ns3::Hash::Hash32Function_ptr*')
+    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, std::size_t const )&', u'ns3::Hash::Hash32Function_ptr&')
+    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, std::size_t const )', u'ns3::Hash::Hash64Function_ptr')
+    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, std::size_t const )*', u'ns3::Hash::Hash64Function_ptr*')
+    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, std::size_t const )&', u'ns3::Hash::Hash64Function_ptr&')
     
     ## Register a nested module for the namespace Function
     
@@ -457,6 +517,7 @@
     register_Ns3Ipv6Address_methods(root_module, root_module['ns3::Ipv6Address'])
     register_Ns3Ipv6Prefix_methods(root_module, root_module['ns3::Ipv6Prefix'])
     register_Ns3Mac48Address_methods(root_module, root_module['ns3::Mac48Address'])
+    register_Ns3Mac8Address_methods(root_module, root_module['ns3::Mac8Address'])
     register_Ns3NodeContainer_methods(root_module, root_module['ns3::NodeContainer'])
     register_Ns3ObjectBase_methods(root_module, root_module['ns3::ObjectBase'])
     register_Ns3ObjectDeleter_methods(root_module, root_module['ns3::ObjectDeleter'])
@@ -563,6 +624,7 @@
     register_Ns3ObjectFactoryChecker_methods(root_module, root_module['ns3::ObjectFactoryChecker'])
     register_Ns3ObjectFactoryValue_methods(root_module, root_module['ns3::ObjectFactoryValue'])
     register_Ns3OhBuildingsPropagationLossModel_methods(root_module, root_module['ns3::OhBuildingsPropagationLossModel'])
+    register_Ns3OutdoorPositionAllocator_methods(root_module, root_module['ns3::OutdoorPositionAllocator'])
     register_Ns3Packet_methods(root_module, root_module['ns3::Packet'])
     register_Ns3ParetoRandomVariable_methods(root_module, root_module['ns3::ParetoRandomVariable'])
     register_Ns3TimeValue_methods(root_module, root_module['ns3::TimeValue'])
@@ -1362,18 +1424,18 @@
     cls.add_constructor([])
     ## hash.h (module 'core'): ns3::Hasher::Hasher(ns3::Ptr<ns3::Hash::Implementation> hp) [constructor]
     cls.add_constructor([param('ns3::Ptr< ns3::Hash::Implementation >', 'hp')])
-    ## hash.h (module 'core'): uint32_t ns3::Hasher::GetHash32(char const * buffer, size_t const size) [member function]
+    ## hash.h (module 'core'): uint32_t ns3::Hasher::GetHash32(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')])
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')])
     ## hash.h (module 'core'): uint32_t ns3::Hasher::GetHash32(std::string const s) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
                    [param('std::string const', 's')])
-    ## hash.h (module 'core'): uint64_t ns3::Hasher::GetHash64(char const * buffer, size_t const size) [member function]
+    ## hash.h (module 'core'): uint64_t ns3::Hasher::GetHash64(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash64', 
                    'uint64_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')])
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')])
     ## hash.h (module 'core'): uint64_t ns3::Hasher::GetHash64(std::string const s) [member function]
     cls.add_method('GetHash64', 
                    'uint64_t', 
@@ -1643,7 +1705,7 @@
     cls.add_method('IsAllHostsMulticast', 
                    'bool', 
                    [], 
-                   is_const=True)
+                   deprecated=True, is_const=True)
     ## ipv6-address.h (module 'network'): bool ns3::Ipv6Address::IsAllNodesMulticast() const [member function]
     cls.add_method('IsAllNodesMulticast', 
                    'bool', 
@@ -1719,6 +1781,11 @@
                    'ns3::Ipv6Address', 
                    [param('ns3::Mac64Address', 'addr'), param('ns3::Ipv6Address', 'prefix')], 
                    is_static=True)
+    ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::MakeAutoconfiguredAddress(ns3::Mac8Address addr, ns3::Ipv6Address prefix) [member function]
+    cls.add_method('MakeAutoconfiguredAddress', 
+                   'ns3::Ipv6Address', 
+                   [param('ns3::Mac8Address', 'addr'), param('ns3::Ipv6Address', 'prefix')], 
+                   is_static=True)
     ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::MakeAutoconfiguredLinkLocalAddress(ns3::Mac16Address mac) [member function]
     cls.add_method('MakeAutoconfiguredLinkLocalAddress', 
                    'ns3::Ipv6Address', 
@@ -1734,6 +1801,11 @@
                    'ns3::Ipv6Address', 
                    [param('ns3::Mac64Address', 'mac')], 
                    is_static=True)
+    ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::MakeAutoconfiguredLinkLocalAddress(ns3::Mac8Address mac) [member function]
+    cls.add_method('MakeAutoconfiguredLinkLocalAddress', 
+                   'ns3::Ipv6Address', 
+                   [param('ns3::Mac8Address', 'mac')], 
+                   is_static=True)
     ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::MakeIpv4MappedAddress(ns3::Ipv4Address addr) [member function]
     cls.add_method('MakeIpv4MappedAddress', 
                    'ns3::Ipv6Address', 
@@ -1894,6 +1966,48 @@
                    is_static=True)
     return
 
+def register_Ns3Mac8Address_methods(root_module, cls):
+    cls.add_binary_comparison_operator('<')
+    cls.add_binary_comparison_operator('==')
+    cls.add_binary_comparison_operator('!=')
+    cls.add_output_stream_operator()
+    ## mac8-address.h (module 'network'): ns3::Mac8Address::Mac8Address(ns3::Mac8Address const & arg0) [constructor]
+    cls.add_constructor([param('ns3::Mac8Address const &', 'arg0')])
+    ## mac8-address.h (module 'network'): ns3::Mac8Address::Mac8Address() [constructor]
+    cls.add_constructor([])
+    ## mac8-address.h (module 'network'): ns3::Mac8Address::Mac8Address(uint8_t addr) [constructor]
+    cls.add_constructor([param('uint8_t', 'addr')])
+    ## mac8-address.h (module 'network'): static ns3::Mac8Address ns3::Mac8Address::Allocate() [member function]
+    cls.add_method('Allocate', 
+                   'ns3::Mac8Address', 
+                   [], 
+                   is_static=True)
+    ## mac8-address.h (module 'network'): static ns3::Mac8Address ns3::Mac8Address::ConvertFrom(ns3::Address const & address) [member function]
+    cls.add_method('ConvertFrom', 
+                   'ns3::Mac8Address', 
+                   [param('ns3::Address const &', 'address')], 
+                   is_static=True)
+    ## mac8-address.h (module 'network'): void ns3::Mac8Address::CopyFrom(uint8_t const * pBuffer) [member function]
+    cls.add_method('CopyFrom', 
+                   'void', 
+                   [param('uint8_t const *', 'pBuffer')])
+    ## mac8-address.h (module 'network'): void ns3::Mac8Address::CopyTo(uint8_t * pBuffer) const [member function]
+    cls.add_method('CopyTo', 
+                   'void', 
+                   [param('uint8_t *', 'pBuffer')], 
+                   is_const=True)
+    ## mac8-address.h (module 'network'): static ns3::Mac8Address ns3::Mac8Address::GetBroadcast() [member function]
+    cls.add_method('GetBroadcast', 
+                   'ns3::Mac8Address', 
+                   [], 
+                   is_static=True)
+    ## mac8-address.h (module 'network'): static bool ns3::Mac8Address::IsMatchingType(ns3::Address const & address) [member function]
+    cls.add_method('IsMatchingType', 
+                   'bool', 
+                   [param('ns3::Address const &', 'address')], 
+                   is_static=True)
+    return
+
 def register_Ns3NodeContainer_methods(root_module, cls):
     ## node-container.h (module 'network'): ns3::NodeContainer::NodeContainer(ns3::NodeContainer const & arg0) [constructor]
     cls.add_constructor([param('ns3::NodeContainer const &', 'arg0')])
@@ -1928,6 +2042,11 @@
                    'ns3::NodeContainer::Iterator', 
                    [], 
                    is_const=True)
+    ## node-container.h (module 'network'): bool ns3::NodeContainer::Contains(uint32_t id) const [member function]
+    cls.add_method('Contains', 
+                   'bool', 
+                   [param('uint32_t', 'id')], 
+                   is_const=True)
     ## node-container.h (module 'network'): void ns3::NodeContainer::Create(uint32_t n) [member function]
     cls.add_method('Create', 
                    'void', 
@@ -2394,24 +2513,25 @@
     ## type-id.h (module 'core'): ns3::TypeId ns3::TypeId::AddTraceSource(std::string name, std::string help, ns3::Ptr<const ns3::TraceSourceAccessor> accessor) [member function]
     cls.add_method('AddTraceSource', 
                    'ns3::TypeId', 
-                   [param('std::string', 'name'), param('std::string', 'help'), param('ns3::Ptr< ns3::TraceSourceAccessor const >', 'accessor')])
+                   [param('std::string', 'name'), param('std::string', 'help'), param('ns3::Ptr< ns3::TraceSourceAccessor const >', 'accessor')], 
+                   deprecated=True)
     ## type-id.h (module 'core'): ns3::TypeId ns3::TypeId::AddTraceSource(std::string name, std::string help, ns3::Ptr<const ns3::TraceSourceAccessor> accessor, std::string callback, ns3::TypeId::SupportLevel supportLevel=::ns3::TypeId::SupportLevel::SUPPORTED, std::string const & supportMsg="") [member function]
     cls.add_method('AddTraceSource', 
                    'ns3::TypeId', 
                    [param('std::string', 'name'), param('std::string', 'help'), param('ns3::Ptr< ns3::TraceSourceAccessor const >', 'accessor'), param('std::string', 'callback'), param('ns3::TypeId::SupportLevel', 'supportLevel', default_value='::ns3::TypeId::SupportLevel::SUPPORTED'), param('std::string const &', 'supportMsg', default_value='""')])
-    ## type-id.h (module 'core'): ns3::TypeId::AttributeInformation ns3::TypeId::GetAttribute(uint32_t i) const [member function]
+    ## type-id.h (module 'core'): ns3::TypeId::AttributeInformation ns3::TypeId::GetAttribute(std::size_t i) const [member function]
     cls.add_method('GetAttribute', 
                    'ns3::TypeId::AttributeInformation', 
-                   [param('uint32_t', 'i')], 
+                   [param('std::size_t', 'i')], 
                    is_const=True)
-    ## type-id.h (module 'core'): std::string ns3::TypeId::GetAttributeFullName(uint32_t i) const [member function]
+    ## type-id.h (module 'core'): std::string ns3::TypeId::GetAttributeFullName(std::size_t i) const [member function]
     cls.add_method('GetAttributeFullName', 
                    'std::string', 
-                   [param('uint32_t', 'i')], 
+                   [param('std::size_t', 'i')], 
                    is_const=True)
-    ## type-id.h (module 'core'): uint32_t ns3::TypeId::GetAttributeN() const [member function]
+    ## type-id.h (module 'core'): std::size_t ns3::TypeId::GetAttributeN() const [member function]
     cls.add_method('GetAttributeN', 
-                   'uint32_t', 
+                   'std::size_t', 
                    [], 
                    is_const=True)
     ## type-id.h (module 'core'): ns3::Callback<ns3::ObjectBase *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> ns3::TypeId::GetConstructor() const [member function]
@@ -2439,14 +2559,14 @@
                    'ns3::TypeId', 
                    [], 
                    is_const=True)
-    ## type-id.h (module 'core'): static ns3::TypeId ns3::TypeId::GetRegistered(uint32_t i) [member function]
+    ## type-id.h (module 'core'): static ns3::TypeId ns3::TypeId::GetRegistered(uint16_t i) [member function]
     cls.add_method('GetRegistered', 
                    'ns3::TypeId', 
-                   [param('uint32_t', 'i')], 
+                   [param('uint16_t', 'i')], 
                    is_static=True)
-    ## type-id.h (module 'core'): static uint32_t ns3::TypeId::GetRegisteredN() [member function]
+    ## type-id.h (module 'core'): static uint16_t ns3::TypeId::GetRegisteredN() [member function]
     cls.add_method('GetRegisteredN', 
-                   'uint32_t', 
+                   'uint16_t', 
                    [], 
                    is_static=True)
     ## type-id.h (module 'core'): std::size_t ns3::TypeId::GetSize() const [member function]
@@ -2454,14 +2574,14 @@
                    'std::size_t', 
                    [], 
                    is_const=True)
-    ## type-id.h (module 'core'): ns3::TypeId::TraceSourceInformation ns3::TypeId::GetTraceSource(uint32_t i) const [member function]
+    ## type-id.h (module 'core'): ns3::TypeId::TraceSourceInformation ns3::TypeId::GetTraceSource(std::size_t i) const [member function]
     cls.add_method('GetTraceSource', 
                    'ns3::TypeId::TraceSourceInformation', 
-                   [param('uint32_t', 'i')], 
+                   [param('std::size_t', 'i')], 
                    is_const=True)
-    ## type-id.h (module 'core'): uint32_t ns3::TypeId::GetTraceSourceN() const [member function]
+    ## type-id.h (module 'core'): std::size_t ns3::TypeId::GetTraceSourceN() const [member function]
     cls.add_method('GetTraceSourceN', 
-                   'uint32_t', 
+                   'std::size_t', 
                    [], 
                    is_const=True)
     ## type-id.h (module 'core'): uint16_t ns3::TypeId::GetUid() const [member function]
@@ -2523,10 +2643,10 @@
                    'bool', 
                    [], 
                    is_const=True)
-    ## type-id.h (module 'core'): bool ns3::TypeId::SetAttributeInitialValue(uint32_t i, ns3::Ptr<const ns3::AttributeValue> initialValue) [member function]
+    ## type-id.h (module 'core'): bool ns3::TypeId::SetAttributeInitialValue(std::size_t i, ns3::Ptr<const ns3::AttributeValue> initialValue) [member function]
     cls.add_method('SetAttributeInitialValue', 
                    'bool', 
-                   [param('uint32_t', 'i'), param('ns3::Ptr< ns3::AttributeValue const >', 'initialValue')])
+                   [param('std::size_t', 'i'), param('ns3::Ptr< ns3::AttributeValue const >', 'initialValue')])
     ## type-id.h (module 'core'): ns3::TypeId ns3::TypeId::SetGroupName(std::string groupName) [member function]
     cls.add_method('SetGroupName', 
                    'ns3::TypeId', 
@@ -2718,6 +2838,11 @@
                    'uint32_t', 
                    [param('ns3::Buffer::Iterator', 'start')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## chunk.h (module 'network'): uint32_t ns3::Chunk::Deserialize(ns3::Buffer::Iterator start, ns3::Buffer::Iterator end) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start'), param('ns3::Buffer::Iterator', 'end')], 
+                   is_virtual=True)
     ## chunk.h (module 'network'): static ns3::TypeId ns3::Chunk::GetTypeId() [member function]
     cls.add_method('GetTypeId', 
                    'ns3::TypeId', 
@@ -3498,6 +3623,11 @@
                    'uint32_t', 
                    [param('ns3::Buffer::Iterator', 'end')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## trailer.h (module 'network'): uint32_t ns3::Trailer::Deserialize(ns3::Buffer::Iterator start, ns3::Buffer::Iterator end) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start'), param('ns3::Buffer::Iterator', 'end')], 
+                   is_virtual=True)
     ## trailer.h (module 'network'): uint32_t ns3::Trailer::GetSerializedSize() const [member function]
     cls.add_method('GetSerializedSize', 
                    'uint32_t', 
@@ -4212,10 +4342,10 @@
                    is_static=True)
     ## random-variable-stream.h (module 'core'): ns3::DeterministicRandomVariable::DeterministicRandomVariable() [constructor]
     cls.add_constructor([])
-    ## random-variable-stream.h (module 'core'): void ns3::DeterministicRandomVariable::SetValueArray(double * values, uint64_t length) [member function]
+    ## random-variable-stream.h (module 'core'): void ns3::DeterministicRandomVariable::SetValueArray(double * values, std::size_t length) [member function]
     cls.add_method('SetValueArray', 
                    'void', 
-                   [param('double *', 'values'), param('uint64_t', 'length')])
+                   [param('double *', 'values'), param('std::size_t', 'length')])
     ## random-variable-stream.h (module 'core'): double ns3::DeterministicRandomVariable::GetValue() [member function]
     cls.add_method('GetValue', 
                    'double', 
@@ -5472,6 +5602,40 @@
                    is_const=True, is_virtual=True)
     return
 
+def register_Ns3OutdoorPositionAllocator_methods(root_module, cls):
+    ## building-position-allocator.h (module 'buildings'): ns3::OutdoorPositionAllocator::OutdoorPositionAllocator(ns3::OutdoorPositionAllocator const & arg0) [constructor]
+    cls.add_constructor([param('ns3::OutdoorPositionAllocator const &', 'arg0')])
+    ## building-position-allocator.h (module 'buildings'): ns3::OutdoorPositionAllocator::OutdoorPositionAllocator() [constructor]
+    cls.add_constructor([])
+    ## building-position-allocator.h (module 'buildings'): int64_t ns3::OutdoorPositionAllocator::AssignStreams(int64_t stream) [member function]
+    cls.add_method('AssignStreams', 
+                   'int64_t', 
+                   [param('int64_t', 'stream')], 
+                   is_virtual=True)
+    ## building-position-allocator.h (module 'buildings'): ns3::Vector ns3::OutdoorPositionAllocator::GetNext() const [member function]
+    cls.add_method('GetNext', 
+                   'ns3::Vector', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## building-position-allocator.h (module 'buildings'): static ns3::TypeId ns3::OutdoorPositionAllocator::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## building-position-allocator.h (module 'buildings'): void ns3::OutdoorPositionAllocator::SetX(ns3::Ptr<ns3::RandomVariableStream> x) [member function]
+    cls.add_method('SetX', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::RandomVariableStream >', 'x')])
+    ## building-position-allocator.h (module 'buildings'): void ns3::OutdoorPositionAllocator::SetY(ns3::Ptr<ns3::RandomVariableStream> y) [member function]
+    cls.add_method('SetY', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::RandomVariableStream >', 'y')])
+    ## building-position-allocator.h (module 'buildings'): void ns3::OutdoorPositionAllocator::SetZ(ns3::Ptr<ns3::RandomVariableStream> z) [member function]
+    cls.add_method('SetZ', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::RandomVariableStream >', 'z')])
+    return
+
 def register_Ns3Packet_methods(root_module, cls):
     cls.add_output_stream_operator()
     ## packet.h (module 'network'): ns3::Packet::Packet() [constructor]
@@ -5585,6 +5749,11 @@
                    'uint32_t', 
                    [param('ns3::Header &', 'header')], 
                    is_const=True)
+    ## packet.h (module 'network'): uint32_t ns3::Packet::PeekHeader(ns3::Header & header, uint32_t size) const [member function]
+    cls.add_method('PeekHeader', 
+                   'uint32_t', 
+                   [param('ns3::Header &', 'header'), param('uint32_t', 'size')], 
+                   is_const=True)
     ## packet.h (module 'network'): bool ns3::Packet::PeekPacketTag(ns3::Tag & tag) const [member function]
     cls.add_method('PeekPacketTag', 
                    'bool', 
@@ -5629,6 +5798,10 @@
     cls.add_method('RemoveHeader', 
                    'uint32_t', 
                    [param('ns3::Header &', 'header')])
+    ## packet.h (module 'network'): uint32_t ns3::Packet::RemoveHeader(ns3::Header & header, uint32_t size) [member function]
+    cls.add_method('RemoveHeader', 
+                   'uint32_t', 
+                   [param('ns3::Header &', 'header'), param('uint32_t', 'size')])
     ## packet.h (module 'network'): bool ns3::Packet::RemovePacketTag(ns3::Tag & tag) [member function]
     cls.add_method('RemovePacketTag', 
                    'bool', 
@@ -5669,7 +5842,7 @@
     cls.add_method('GetMean', 
                    'double', 
                    [], 
-                   is_const=True)
+                   deprecated=True, is_const=True)
     ## random-variable-stream.h (module 'core'): double ns3::ParetoRandomVariable::GetScale() const [member function]
     cls.add_method('GetScale', 
                    'double', 
@@ -5969,15 +6142,15 @@
     cls.add_constructor([param('ns3::Hash::Implementation const &', 'arg0')])
     ## hash-function.h (module 'core'): ns3::Hash::Implementation::Implementation() [constructor]
     cls.add_constructor([])
-    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Implementation::GetHash32(char const * buffer, size_t const size) [member function]
+    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Implementation::GetHash32(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_pure_virtual=True, is_virtual=True)
-    ## hash-function.h (module 'core'): uint64_t ns3::Hash::Implementation::GetHash64(char const * buffer, size_t const size) [member function]
+    ## hash-function.h (module 'core'): uint64_t ns3::Hash::Implementation::GetHash64(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash64', 
                    'uint64_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_virtual=True)
     ## hash-function.h (module 'core'): void ns3::Hash::Implementation::clear() [member function]
     cls.add_method('clear', 
@@ -6013,10 +6186,10 @@
     cls.add_constructor([param('ns3::Hash::Function::Hash32 const &', 'arg0')])
     ## hash-function.h (module 'core'): ns3::Hash::Function::Hash32::Hash32(ns3::Hash::Hash32Function_ptr hp) [constructor]
     cls.add_constructor([param('ns3::Hash::Hash32Function_ptr', 'hp')])
-    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Function::Hash32::GetHash32(char const * buffer, size_t const size) [member function]
+    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Function::Hash32::GetHash32(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_virtual=True)
     ## hash-function.h (module 'core'): void ns3::Hash::Function::Hash32::clear() [member function]
     cls.add_method('clear', 
@@ -6030,15 +6203,15 @@
     cls.add_constructor([param('ns3::Hash::Function::Hash64 const &', 'arg0')])
     ## hash-function.h (module 'core'): ns3::Hash::Function::Hash64::Hash64(ns3::Hash::Hash64Function_ptr hp) [constructor]
     cls.add_constructor([param('ns3::Hash::Hash64Function_ptr', 'hp')])
-    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Function::Hash64::GetHash32(char const * buffer, size_t const size) [member function]
+    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Function::Hash64::GetHash32(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_virtual=True)
-    ## hash-function.h (module 'core'): uint64_t ns3::Hash::Function::Hash64::GetHash64(char const * buffer, size_t const size) [member function]
+    ## hash-function.h (module 'core'): uint64_t ns3::Hash::Function::Hash64::GetHash64(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash64', 
                    'uint64_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_virtual=True)
     ## hash-function.h (module 'core'): void ns3::Hash::Function::Hash64::clear() [member function]
     cls.add_method('clear', 
@@ -6052,15 +6225,15 @@
     cls.add_constructor([param('ns3::Hash::Function::Murmur3 const &', 'arg0')])
     ## hash-murmur3.h (module 'core'): ns3::Hash::Function::Murmur3::Murmur3() [constructor]
     cls.add_constructor([])
-    ## hash-murmur3.h (module 'core'): uint32_t ns3::Hash::Function::Murmur3::GetHash32(char const * buffer, size_t const size) [member function]
+    ## hash-murmur3.h (module 'core'): uint32_t ns3::Hash::Function::Murmur3::GetHash32(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_virtual=True)
-    ## hash-murmur3.h (module 'core'): uint64_t ns3::Hash::Function::Murmur3::GetHash64(char const * buffer, size_t const size) [member function]
+    ## hash-murmur3.h (module 'core'): uint64_t ns3::Hash::Function::Murmur3::GetHash64(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash64', 
                    'uint64_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_virtual=True)
     ## hash-murmur3.h (module 'core'): void ns3::Hash::Function::Murmur3::clear() [member function]
     cls.add_method('clear', 
@@ -6071,16 +6244,16 @@
 
 def register_functions(root_module):
     module = root_module
-    register_functions_ns3_FatalImpl(module.get_submodule('FatalImpl'), root_module)
-    register_functions_ns3_Hash(module.get_submodule('Hash'), root_module)
-    register_functions_ns3_TracedValueCallback(module.get_submodule('TracedValueCallback'), root_module)
+    register_functions_ns3_FatalImpl(module.add_cpp_namespace('FatalImpl'), root_module)
+    register_functions_ns3_Hash(module.add_cpp_namespace('Hash'), root_module)
+    register_functions_ns3_TracedValueCallback(module.add_cpp_namespace('TracedValueCallback'), root_module)
     return
 
 def register_functions_ns3_FatalImpl(module, root_module):
     return
 
 def register_functions_ns3_Hash(module, root_module):
-    register_functions_ns3_Hash_Function(module.get_submodule('Function'), root_module)
+    register_functions_ns3_Hash_Function(module.add_cpp_namespace('Function'), root_module)
     return
 
 def register_functions_ns3_Hash_Function(module, root_module):
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/buildings/doc/source/buildings-design.rst iab-psc/src/buildings/doc/source/buildings-design.rst
--- ns3-mmwave-iab/src/buildings/doc/source/buildings-design.rst	2019-02-15 18:12:55.059613983 +0100
+++ iab-psc/src/buildings/doc/source/buildings-design.rst	2019-02-15 18:13:15.451798012 +0100
@@ -233,7 +233,7 @@
 
 For the ITU-R P.1411 model we consider both the LOS and NLoS versions. In particular, we considers the LoS propagation for distances that are shorted than a tunable threshold (``m_itu1411NlosThreshold``). In case on NLoS propagation, the over the roof-top model is taken in consideration for modeling both macro BS and SC. In case on NLoS several parameters scenario dependent have been included, such as average street width, orientation, etc. The values of such parameters have to be properly set according to the scenario implemented, the model does not calculate natively their values. In case any values is provided, the standard ones are used, apart for the height of the mobile and BS, which instead their integrity is tested directly in the code (i.e., they have to be greater then zero).  In the following we give the expressions of the components of the model.
 
-We also note that the use of different propagation models (OH, I1411, I1238 with their variants) in HybridBuildingsPropagationLossModel can result in discontinuities of the pathloss with respect to distance. A proper tuning of the attributes (especially the distance threshold attributes) can avoid these discontinuities. However, since the behavior of each model depends on several other parameters (frequency, node heigth, etc), there is no default value of these thresholds that can avoid the discontinuities in all possible configurations. Hence, an appropriate tuning of these parameters is left to the user.
+We also note that the use of different propagation models (OH, I1411, I1238 with their variants) in HybridBuildingsPropagationLossModel can result in discontinuities of the pathloss with respect to distance. A proper tuning of the attributes (especially the distance threshold attributes) can avoid these discontinuities. However, since the behavior of each model depends on several other parameters (frequency, node height, etc), there is no default value of these thresholds that can avoid the discontinuities in all possible configurations. Hence, an appropriate tuning of these parameters is left to the user.
 
 
 OhBuildingsPropagationLossModel
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/buildings/doc/source/buildings-user.rst iab-psc/src/buildings/doc/source/buildings-user.rst
--- ns3-mmwave-iab/src/buildings/doc/source/buildings-user.rst	2019-02-15 18:12:55.059613983 +0100
+++ iab-psc/src/buildings/doc/source/buildings-user.rst	2019-02-15 18:13:15.451798012 +0100
@@ -71,7 +71,7 @@
 Nodes and mobility models are configured as usual, however in order to
 use them with the buildings model you need an additional call to
 ``BuildingsHelper::Install()``, so as to let the mobility model include
-the informtion on their position w.r.t. the buildings. Here is an example::
+the information on their position w.r.t. the buildings. Here is an example::
 
     MobilityHelper mobility;
     mobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
@@ -125,12 +125,12 @@
 in special positions with respect to buildings:
 
  - ``RandomBuildingPositionAllocator``: Allocate each position by
-   randomly chosing a building from the list of all buildings, and
-   then randomly chosing a position inside the building. 
+   randomly choosing a building from the list of all buildings, and
+   then randomly choosing a position inside the building. 
 
  - ``RandomRoomPositionAllocator``: Allocate each position by randomly
-   chosing a room from the list of rooms in all buildings, and then
-   randomly chosing a position inside the room. 
+   choosing a room from the list of rooms in all buildings, and then
+   randomly choosing a position inside the room. 
 
  - ``SameRoomPositionAllocator``: Walks a given NodeContainer
    sequentially, and for each node allocate a new position randomly in
@@ -180,7 +180,7 @@
 * number of floors.
 * number of rooms in x-axis and y-axis (rooms can be placed only in a grid way).
 
-The ``BuildingMobilityLossModel`` parameter configurable with the ns3 attribute system is represented by the bound (string ``Bounds``) of the simulation area by providing a ``Box`` class with the area bounds. Moreover, by means of its methos the following parameters can be configured:
+The ``BuildingMobilityLossModel`` parameter configurable with the ns3 attribute system is represented by the bound (string ``Bounds``) of the simulation area by providing a ``Box`` class with the area bounds. Moreover, by means of its methods the following parameters can be configured:
 
 * the number of floor the node is placed (default 0).
 * the position in the rooms grid.
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/buildings/helper/building-allocator.cc iab-psc/src/buildings/helper/building-allocator.cc
--- ns3-mmwave-iab/src/buildings/helper/building-allocator.cc	2019-02-15 18:12:55.059613983 +0100
+++ iab-psc/src/buildings/helper/building-allocator.cc	2019-02-15 18:13:15.451798012 +0100
@@ -52,7 +52,7 @@
     .SetParent<Object> ()
     .AddConstructor<GridBuildingAllocator> ()
     .SetGroupName ("Buildings")
-    .AddAttribute ("GridWidth", "The number of objects layed out on a line.",
+    .AddAttribute ("GridWidth", "The number of objects laid out on a line.",
                    UintegerValue (10),
                    MakeUintegerAccessor (&GridBuildingAllocator::m_n),
                    MakeUintegerChecker<uint32_t> ())
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/buildings/helper/building-position-allocator.cc iab-psc/src/buildings/helper/building-position-allocator.cc
--- ns3-mmwave-iab/src/buildings/helper/building-position-allocator.cc	2019-02-15 18:12:55.059613983 +0100
+++ iab-psc/src/buildings/helper/building-position-allocator.cc	2019-02-15 18:13:15.451798012 +0100
@@ -27,11 +27,11 @@
 #include "ns3/uinteger.h"
 #include "ns3/enum.h"
 #include "ns3/boolean.h"
-#include "ns3/string.h"
-#include "ns3/pointer.h"
 #include "ns3/log.h"
 #include "ns3/box.h"
 #include "ns3/building.h"
+#include "ns3/string.h"
+#include "ns3/pointer.h"
 #include <cmath>
 
 #include "ns3/building-list.h"
@@ -106,11 +106,11 @@
   return 1;
 }
 
+
 NS_OBJECT_ENSURE_REGISTERED (OutdoorPositionAllocator);
 
 OutdoorPositionAllocator::OutdoorPositionAllocator ()
 {
-  m_maxAttempts = 1000;
 }
 
 TypeId
@@ -135,14 +135,14 @@
                    StringValue ("ns3::UniformRandomVariable[Min=0.0|Max=1.0]"),
                    MakePointerAccessor (&OutdoorPositionAllocator::m_z),
                    MakePointerChecker<RandomVariableStream> ())
-    .AddAttribute ("MaxNumAttempts",
-                   "Maximum number of attempts before giving up",
+    .AddAttribute ("MaxAttempts",
+                   "Maximum number of attempts for the rejection sampling before giving up.",
                    UintegerValue (1000),
                    MakeUintegerAccessor (&OutdoorPositionAllocator::m_maxAttempts),
                    MakeUintegerChecker<uint32_t> ())
-    ;
+  ;
 
-  return tid; 
+  return tid;
 }
 
 void
@@ -161,54 +161,55 @@
   m_z = z;
 }
 
-Vector 
+Vector
 OutdoorPositionAllocator::GetNext () const
 {
-  NS_ASSERT_MSG (BuildingList::GetNBuildings () > 0, "no building found");
+  NS_ABORT_MSG_IF (BuildingList::GetNBuildings () == 0, "no building found");
 
   bool outdoor = false;
   uint32_t attempts = 0;
-  Vector pos = Vector(0,0,0);
-  
-  while(!outdoor && attempts < m_maxAttempts)
-  {
-    // get a random position
-    double x = m_x->GetValue ();
-    double y = m_y->GetValue ();
-    double z = m_z->GetValue ();
+  Vector position = Vector (0,0,0);
 
-    pos = Vector (x, y, z);
+  while (!outdoor && attempts < m_maxAttempts)
+    {
+      // get a random position
+      double x = m_x->GetValue ();
+      double y = m_y->GetValue ();
+      double z = m_z->GetValue ();
 
-    NS_LOG_INFO("pos " << pos);
+      position = Vector (x, y, z);
 
-    bool inside = false;
-    for (BuildingList::Iterator bit = BuildingList::Begin (); bit != BuildingList::End (); ++bit)
-    {
-      if((*bit)->IsInside (pos))
-      {
-        NS_LOG_INFO("Pos " << pos << " inside building " << (*bit)->GetBoundaries().xMin << " " << (*bit)->GetBoundaries().xMax << " "
-            << (*bit)->GetBoundaries().yMin << " " << (*bit)->GetBoundaries().yMax << " "
-            << (*bit)->GetBoundaries().zMin << " " << (*bit)->GetBoundaries().zMax);
-        inside = true;
-        break;
-      }
-    }
+      NS_LOG_INFO ("Position " << position);
 
-    if(inside)
-    {
-      NS_LOG_INFO("Inside a building, attemp " << attempts << " out of " << m_maxAttempts);
-      attempts++; 
-    }
-    else
-    {
-      NS_LOG_INFO("Outdoor position found " << pos);
-      outdoor = true;
+      bool inside = false;
+      for (BuildingList::Iterator bit = BuildingList::Begin (); bit != BuildingList::End (); ++bit)
+        {
+          if ((*bit)->IsInside (position))
+            {
+              NS_LOG_INFO ("Position " << position << " is inside the building with boundaries "
+                                       << (*bit)->GetBoundaries ().xMin << " " << (*bit)->GetBoundaries ().xMax << " "
+                                       << (*bit)->GetBoundaries ().yMin << " " << (*bit)->GetBoundaries ().yMax << " "
+                                       << (*bit)->GetBoundaries ().zMin << " " << (*bit)->GetBoundaries ().zMax);
+              inside = true;
+              break;
+            }
+        }
+
+      if (inside)
+        {
+          NS_LOG_INFO ("Inside a building, attempt " << attempts << " out of " << m_maxAttempts);
+          attempts++;
+        }
+      else
+        {
+          NS_LOG_INFO ("Outdoor position found " << position);
+          outdoor = true;
+        }
     }
-  }
 
-  NS_ASSERT_MSG(attempts < m_maxAttempts, "Too many attempts, give up");
-  NS_ASSERT_MSG(outdoor, "Still indoor, give up");
-  return pos;
+  NS_ABORT_MSG_IF (attempts >= m_maxAttempts, "Too many attempts, give up");
+  NS_ABORT_MSG_IF (!outdoor, "Still indoor, give up");
+  return position;
 }
 
 int64_t
@@ -221,7 +222,6 @@
 }
 
 
-
 NS_OBJECT_ENSURE_REGISTERED (RandomRoomPositionAllocator);
 
 
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/buildings/helper/building-position-allocator.h iab-psc/src/buildings/helper/building-position-allocator.h
--- ns3-mmwave-iab/src/buildings/helper/building-position-allocator.h	2019-02-15 18:12:55.059613983 +0100
+++ iab-psc/src/buildings/helper/building-position-allocator.h	2019-02-15 18:13:15.451798012 +0100
@@ -18,7 +18,6 @@
  * Author: Nicola Baldo <nbaldo@cttc.es>
  *         Michele Polese <michele.polese@gmail.com> for the OutdoorPositionAllocator class
  */
-
 #ifndef BUILDING_POSITION_ALLOCATOR_H
 #define BUILDING_POSITION_ALLOCATOR_H
 
@@ -34,8 +33,8 @@
 
 
 /**
- * Allocate each position by randomly chosing a building from the list
- * of all buildings, and then randomly chosing a position inside the building.
+ * Allocate each position by randomly choosing a building from the list
+ * of all buildings, and then randomly choosing a position inside the building.
  * 
  */
 class RandomBuildingPositionAllocator : public PositionAllocator
@@ -68,10 +67,19 @@
   Ptr<UniformRandomVariable> m_rand;
 };
 
-
 /**
- * Allocate each position outside of existing buildings
- * 
+ * \ingroup buildings
+ * \brief allocate outdoor positions
+ *
+ * Allocate positions outside of existing buildings using rejection sampling.
+ * This class extracts a random position in a box defined by the three 
+ * RandomVariableStreams for the X, Y and Z dimensions (similarly to 
+ * RandomBoxPositionAllocator), until a position is found that is outdoors 
+ * with respect to all of the buildings in the scenario, or a maximum number 
+ * of attempts is reached.  The RandomVariableStream and the maximum number 
+ * of attempts can be set using attributes.  If the maximum number of 
+ * attempts is reached, then the simulation aborts due to failure of properly
+ * positioning the node.
  */
 class OutdoorPositionAllocator : public PositionAllocator
 {
@@ -118,11 +126,9 @@
   uint32_t m_maxAttempts; //!< maximum number of attempts before giving up
 };
 
-
-
 /**
- * Allocate each position by randomly chosing a room from the list
- * of all buildings, and then randomly chosing a position inside the room.
+ * Allocate each position by randomly choosing a room from the list
+ * of all buildings, and then randomly choosing a position inside the room.
  * The selection of the room is always done without replacement.
  * 
  */
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/buildings/model/building-list.cc iab-psc/src/buildings/model/building-list.cc
--- ns3-mmwave-iab/src/buildings/model/building-list.cc	2019-02-15 18:12:55.059613983 +0100
+++ iab-psc/src/buildings/model/building-list.cc	2019-02-15 18:13:15.451798012 +0100
@@ -16,7 +16,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Jaume Nin <jaume.nin@cttc,cat>
- * Based on BuildingList implemenation by Mathieu Lacage  <mathieu.lacage@sophia.inria.fr>
+ * Based on BuildingList implementation by Mathieu Lacage  <mathieu.lacage@sophia.inria.fr>
  *
  */
 #include "building-list.h"
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/buildings/model/group-slave-outdoor-mobility-model.cc iab-psc/src/buildings/model/group-slave-outdoor-mobility-model.cc
--- ns3-mmwave-iab/src/buildings/model/group-slave-outdoor-mobility-model.cc	1970-01-01 01:00:00.000000000 +0100
+++ iab-psc/src/buildings/model/group-slave-outdoor-mobility-model.cc	2019-02-15 18:13:15.451798012 +0100
@@ -0,0 +1,61 @@
+/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2019 University of Padova
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Michele Polese <michele.polese@gmail.com>
+ */
+#include "group-slave-outdoor-mobility-model.h"
+#include "ns3/log.h"
+#include "ns3/node.h"
+#include "ns3/building.h"
+#include "ns3/building-list.h"
+
+namespace ns3 {
+
+NS_OBJECT_ENSURE_REGISTERED (GroupSlaveOutdoorMobilityModel);
+NS_LOG_COMPONENT_DEFINE ("GroupSlaveOutdoorMobilityModel");
+
+TypeId
+GroupSlaveOutdoorMobilityModel::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::GroupSlaveOutdoorMobilityModel")
+    .SetParent<GroupSlaveMobilityModel> ()
+    .SetGroupName ("Mobility")
+    .AddConstructor<GroupSlaveOutdoorMobilityModel> ();
+  return tid;
+}
+
+bool
+GroupSlaveOutdoorMobilityModel::CheckForSpecialConditions (Vector position) const
+{
+  return IsOutdoor (position);
+}
+
+bool
+GroupSlaveOutdoorMobilityModel::IsOutdoor (Vector position) const
+{
+  for (BuildingList::Iterator bit = BuildingList::Begin (); bit != BuildingList::End (); ++bit)
+    {
+      if ((*bit)->IsInside (position)) // the position is inside a building
+        {
+          NS_LOG_LOGIC ("Indoor");
+          return false;
+        }
+    }
+  return true;
+}
+
+}
\ Manca newline alla fine del file
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/buildings/model/group-slave-outdoor-mobility-model.h iab-psc/src/buildings/model/group-slave-outdoor-mobility-model.h
--- ns3-mmwave-iab/src/buildings/model/group-slave-outdoor-mobility-model.h	1970-01-01 01:00:00.000000000 +0100
+++ iab-psc/src/buildings/model/group-slave-outdoor-mobility-model.h	2019-02-15 18:13:15.451798012 +0100
@@ -0,0 +1,51 @@
+/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2019 University of Padova
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Michele Polese <michele.polese@gmail.com>
+ */
+#ifndef GROUP_SLAVE_OUTDOOR_MOBILITY_MODEL_H
+#define GROUP_SLAVE_OUTDOOR_MOBILITY_MODEL_H
+
+#include "ns3/group-slave-mobility-model.h"
+
+namespace ns3 {
+
+/**
+ * \ingroup buildings
+ *
+ * \brief MobilityModel which inherits GroupSlaveMobilityModel but also checks if the position of the slave is outdoor
+ */
+class GroupSlaveOutdoorMobilityModel : public GroupSlaveMobilityModel
+{
+public:
+  static TypeId GetTypeId (void);
+
+protected:
+  virtual bool CheckForSpecialConditions (Vector position) const;
+
+private:
+  /**
+   * Check if a position is indoor or not
+   * \param position a Vector with the position
+   * \return true if outdoor
+   */
+  bool IsOutdoor (Vector position) const;
+};
+
+} // namespace ns3
+
+#endif /* GROUP_SLAVE_OUTDOOR_MOBILITY_MODEL_H */
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/buildings/model/hybrid-buildings-propagation-loss-model.cc iab-psc/src/buildings/model/hybrid-buildings-propagation-loss-model.cc
--- ns3-mmwave-iab/src/buildings/model/hybrid-buildings-propagation-loss-model.cc	2019-02-15 18:12:55.059613983 +0100
+++ iab-psc/src/buildings/model/hybrid-buildings-propagation-loss-model.cc	2019-02-15 18:13:15.451798012 +0100
@@ -213,7 +213,7 @@
           if (a1->GetBuilding () == b1->GetBuilding ())
             {
               // nodes are in same building -> indoor communication ITU-R P.1238
-              loss = ItuR1238 (a, b) + InternalWallsLoss (a1, b1);;
+              loss = ItuR1238 (a, b) + InternalWallsLoss (a1, b1);
               NS_LOG_INFO (this << " I-I (same building) ITUR1238 : " << loss);
 
             }
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/buildings/model/mobility-building-info.h iab-psc/src/buildings/model/mobility-building-info.h
--- ns3-mmwave-iab/src/buildings/model/mobility-building-info.h	2019-02-15 18:12:55.059613983 +0100
+++ iab-psc/src/buildings/model/mobility-building-info.h	2019-02-15 18:13:15.451798012 +0100
@@ -40,7 +40,7 @@
  * \ingroup buildings
  * \brief mobility buildings information (to be used by mobility models)
  *
- * This model implements the managment of scenarios where users might be
+ * This model implements the management of scenarios where users might be
  * either indoor (e.g., houses, offices, etc.) and outdoor.
  * 
  */
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/buildings/model/oh-buildings-propagation-loss-model.cc iab-psc/src/buildings/model/oh-buildings-propagation-loss-model.cc
--- ns3-mmwave-iab/src/buildings/model/oh-buildings-propagation-loss-model.cc	2019-02-15 18:12:55.059613983 +0100
+++ iab-psc/src/buildings/model/oh-buildings-propagation-loss-model.cc	2019-02-15 18:13:15.451798012 +0100
@@ -96,7 +96,7 @@
           if (a1->GetBuilding () == b1->GetBuilding ())
             {
               // nodes are in same building -> indoor communication ITU-R P.1238
-              loss = m_okumuraHata->GetLoss (a, b) + InternalWallsLoss (a1, b1);;
+              loss = m_okumuraHata->GetLoss (a, b) + InternalWallsLoss (a1, b1);
               NS_LOG_INFO (this << " I-I (same building)" << loss);
 
             }
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/buildings/model/random-walk-2d-outdoor-mobility-model.cc iab-psc/src/buildings/model/random-walk-2d-outdoor-mobility-model.cc
--- ns3-mmwave-iab/src/buildings/model/random-walk-2d-outdoor-mobility-model.cc	1970-01-01 01:00:00.000000000 +0100
+++ iab-psc/src/buildings/model/random-walk-2d-outdoor-mobility-model.cc	2019-02-15 18:13:15.451798012 +0100
@@ -0,0 +1,396 @@
+/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2006,2007 INRIA
+ * Copyright (c) 2019 University of Padova
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * Author: Michele Polese <michele.polese@gmail.com>
+ */
+#include "random-walk-2d-outdoor-mobility-model.h"
+#include "ns3/enum.h"
+#include "ns3/double.h"
+#include "ns3/string.h"
+#include "ns3/pointer.h"
+#include "ns3/simulator.h"
+#include "ns3/log.h"
+#include "ns3/building.h"
+#include "ns3/building-list.h"
+#include <cmath>
+
+namespace ns3 {
+
+NS_LOG_COMPONENT_DEFINE ("RandomWalk2dOutdoor");
+
+NS_OBJECT_ENSURE_REGISTERED (RandomWalk2dOutdoorMobilityModel);
+
+TypeId
+RandomWalk2dOutdoorMobilityModel::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::RandomWalk2dOutdoorMobilityModel")
+    .SetParent<MobilityModel> ()
+    .SetGroupName ("Mobility")
+    .AddConstructor<RandomWalk2dOutdoorMobilityModel> ()
+    .AddAttribute ("Bounds",
+                   "Bounds of the area to cruise.",
+                   RectangleValue (Rectangle (0.0, 100.0, 0.0, 100.0)),
+                   MakeRectangleAccessor (&RandomWalk2dOutdoorMobilityModel::m_bounds),
+                   MakeRectangleChecker ())
+    .AddAttribute ("Time",
+                   "Change current direction and speed after moving for this delay.",
+                   TimeValue (Seconds (1.0)),
+                   MakeTimeAccessor (&RandomWalk2dOutdoorMobilityModel::m_modeTime),
+                   MakeTimeChecker ())
+    .AddAttribute ("Distance",
+                   "Change current direction and speed after moving for this distance.",
+                   DoubleValue (1.0),
+                   MakeDoubleAccessor (&RandomWalk2dOutdoorMobilityModel::m_modeDistance),
+                   MakeDoubleChecker<double> ())
+    .AddAttribute ("Mode",
+                   "The mode indicates the condition used to "
+                   "change the current speed and direction",
+                   EnumValue (RandomWalk2dOutdoorMobilityModel::MODE_DISTANCE),
+                   MakeEnumAccessor (&RandomWalk2dOutdoorMobilityModel::m_mode),
+                   MakeEnumChecker (RandomWalk2dOutdoorMobilityModel::MODE_DISTANCE, "Distance",
+                                    RandomWalk2dOutdoorMobilityModel::MODE_TIME, "Time"))
+    .AddAttribute ("Direction",
+                   "A random variable used to pick the direction (radians).",
+                   StringValue ("ns3::UniformRandomVariable[Min=0.0|Max=6.283184]"),
+                   MakePointerAccessor (&RandomWalk2dOutdoorMobilityModel::m_direction),
+                   MakePointerChecker<RandomVariableStream> ())
+    .AddAttribute ("Speed",
+                   "A random variable used to pick the speed (m/s).",
+                   StringValue ("ns3::UniformRandomVariable[Min=2.0|Max=4.0]"),
+                   MakePointerAccessor (&RandomWalk2dOutdoorMobilityModel::m_speed),
+                   MakePointerChecker<RandomVariableStream> ())
+    .AddAttribute ("Tolerance",
+                   "Tolerance for the intersection point with buildings (m)",
+                   DoubleValue (1e-6),
+                   MakeDoubleAccessor (&RandomWalk2dOutdoorMobilityModel::m_epsilon),
+                   MakeDoubleChecker<double> ())
+  ;
+  return tid;
+}
+
+void
+RandomWalk2dOutdoorMobilityModel::DoInitialize (void)
+{
+  DoInitializePrivate ();
+  MobilityModel::DoInitialize ();
+}
+
+void
+RandomWalk2dOutdoorMobilityModel::DoInitializePrivate (void)
+{
+  m_helper.Update ();
+  double speed = m_speed->GetValue ();
+  double direction = m_direction->GetValue ();
+  Vector vector (std::cos (direction) * speed,
+                 std::sin (direction) * speed,
+                 0.0);
+  m_helper.SetVelocity (vector);
+  m_helper.Unpause ();
+
+  Time delayLeft;
+  if (m_mode == RandomWalk2dOutdoorMobilityModel::MODE_TIME)
+    {
+      delayLeft = m_modeTime;
+    }
+  else
+    {
+      delayLeft = Seconds (m_modeDistance / speed);
+    }
+  DoWalk (delayLeft);
+}
+
+void
+RandomWalk2dOutdoorMobilityModel::DoWalk (Time delayLeft)
+{
+  Vector position = m_helper.GetCurrentPosition ();
+  Vector speed = m_helper.GetVelocity ();
+  Vector nextPosition = position;
+  nextPosition.x += speed.x * delayLeft.GetSeconds ();
+  nextPosition.y += speed.y * delayLeft.GetSeconds ();
+  m_event.Cancel ();
+
+  // check if the nextPosition is inside a building, or if the line
+  // from position to the next position intersects a building
+  auto outdoorBuilding = IsLineClearOfBuildings (position, nextPosition);
+  bool outdoor = std::get<0> (outdoorBuilding);
+  Ptr<Building> building = std::get<1> (outdoorBuilding);
+
+  if (m_bounds.IsInside (nextPosition))
+    {
+      if (outdoor)
+        {
+          m_event = Simulator::Schedule (delayLeft, &RandomWalk2dOutdoorMobilityModel::DoInitializePrivate, this);
+        }
+      else
+        {
+          NS_LOG_LOGIC ("NextPosition would lead into a building");
+          nextPosition = CalculateIntersectionFromOutside (position, nextPosition, building->GetBoundaries ());
+          Time delay = Seconds ((nextPosition.x - position.x) / speed.x);
+          m_event = Simulator::Schedule (delay, &RandomWalk2dOutdoorMobilityModel::AvoidBuilding, this,
+                                         delayLeft - delay,
+                                         nextPosition
+                                         );
+        }
+    }
+  else
+    {
+      NS_LOG_LOGIC ("Out of bounding box");
+      nextPosition = m_bounds.CalculateIntersection (position, speed);
+      // check that this nextPosition is outdoor
+      auto outdoorBuilding = IsLineClearOfBuildings (position, nextPosition);
+      bool outdoor = std::get<0> (outdoorBuilding);
+      Ptr<Building> building = std::get<1> (outdoorBuilding);
+
+      if (outdoor)
+        {
+          Time delay = Seconds ((nextPosition.x - position.x) / speed.x);
+          m_event = Simulator::Schedule (delay, &RandomWalk2dOutdoorMobilityModel::Rebound, this,
+                                         delayLeft - delay);
+        }
+      else
+        {
+          NS_LOG_LOGIC ("NextPosition would lead into a building");
+          nextPosition = CalculateIntersectionFromOutside (position, nextPosition, building->GetBoundaries ());
+          Time delay = Seconds ((nextPosition.x - position.x) / speed.x);
+          m_event = Simulator::Schedule (delay, &RandomWalk2dOutdoorMobilityModel::AvoidBuilding, this,
+                                         delayLeft - delay,
+                                         nextPosition
+                                         );
+        }
+    }
+  NS_LOG_LOGIC ("Position " << position << " NextPosition " << nextPosition);
+  NotifyCourseChange ();
+}
+
+std::pair<bool, Ptr<Building> >
+RandomWalk2dOutdoorMobilityModel::IsLineClearOfBuildings ( Vector currentPosition, Vector nextPosition ) const
+{
+  for (BuildingList::Iterator bit = BuildingList::Begin (); bit != BuildingList::End (); ++bit)
+    {
+      if ((*bit)->IsInside (nextPosition)) // the nextPosition is inside a building
+        {
+          NS_LOG_LOGIC ("Inside");
+          return std::make_pair (false, (*bit));
+        }
+
+      Box boundaries = (*bit)->GetBoundaries ();
+
+      Vector boxSize (0.5 * (boundaries.xMax - boundaries.xMin),
+                      0.5 * (boundaries.yMax - boundaries.yMin),
+                      0.5 * (boundaries.zMax - boundaries.zMin));
+      Vector boxCenter (boundaries.xMin + boxSize.x,
+                        boundaries.yMin + boxSize.y,
+                        boundaries.zMin + boxSize.z);
+
+      // Put line in box space
+      Vector LB1 (currentPosition.x - boxCenter.x, currentPosition.y - boxCenter.y, currentPosition.z - boxCenter.z);
+      Vector LB2 (nextPosition.x - boxCenter.x, nextPosition.y - boxCenter.y, nextPosition.z - boxCenter.z);
+
+      // Get line midpoint and extent
+      Vector LMid (0.5 * (LB1.x + LB2.x), 0.5 * (LB1.y + LB2.y), 0.5 * (LB1.z + LB2.z));
+      Vector L (LB1.x - LMid.x, LB1.y - LMid.y, LB1.z - LMid.z);
+      Vector LExt ( std::abs (L.x), std::abs (L.y), std::abs (L.z) );
+
+      // Use Separating Axis Test
+      // Separation vector from box center to line center is LMid, since the line is in box space
+      // If the line did not intersect this building, jump to the next building.
+      if ( std::abs ( LMid.x ) > boxSize.x + LExt.x )
+        {
+          continue;
+        }
+      if ( std::abs ( LMid.y ) > boxSize.y + LExt.y )
+        {
+          continue;
+        }
+      if ( std::abs ( LMid.z ) > boxSize.z + LExt.z )
+        {
+          continue;
+        }
+      // Crossproducts of line and each axis
+      if ( std::abs ( LMid.y * L.z - LMid.z * L.y)  >  (boxSize.y * LExt.z + boxSize.z * LExt.y) )
+        {
+          continue;
+        }
+      if ( std::abs ( LMid.x * L.z - LMid.z * L.x)  >  (boxSize.x * LExt.z + boxSize.z * LExt.x) )
+        {
+          continue;
+        }
+      if ( std::abs ( LMid.x * L.y - LMid.y * L.x)  >  (boxSize.x * LExt.y + boxSize.y * LExt.x) )
+        {
+          continue;
+        }
+
+      // No separating axis, the line intersects
+      // If the line intersect this building, return true.
+      return std::make_pair (false, (*bit));
+    }
+
+  Ptr<Building> b = 0;
+  return std::make_pair (true, b);
+}
+
+Vector
+RandomWalk2dOutdoorMobilityModel::CalculateIntersectionFromOutside (const Vector &current, const Vector &next, Box boundaries) const
+{
+  NS_LOG_INFO ("current " << current << " next " << next);
+  bool inside = boundaries.IsInside (current);
+  NS_ASSERT (!inside);
+
+  // get the closest side
+  Rectangle rect = Rectangle (boundaries.xMin, boundaries.xMax, boundaries.yMin, boundaries.yMax);
+  NS_LOG_INFO ("rect " << rect);
+  Rectangle::Side closestSide = rect.GetClosestSide (current);
+
+  double xIntersect = 0;
+  double yIntersect = 0;
+
+  switch (closestSide)
+    {
+    case Rectangle::RIGHT:
+      NS_LOG_INFO ("RIGTH");
+      xIntersect = boundaries.xMax + m_epsilon;
+      yIntersect =
+        (next.y - current.y) / (next.x - current.x) * (xIntersect - current.x) + current.y;
+      break;
+    case Rectangle::LEFT:
+      NS_LOG_INFO ("LEFT");
+      xIntersect = boundaries.xMin - m_epsilon;
+      yIntersect =
+        (next.y - current.y) / (next.x - current.x) * (xIntersect - current.x) + current.y;
+      break;
+    case Rectangle::TOP:
+      NS_LOG_INFO ("TOP");
+      yIntersect = boundaries.yMax + m_epsilon;
+      xIntersect =
+        (next.x - current.x) / (next.y - current.y) * (yIntersect - current.y) + current.x;
+      break;
+    case Rectangle::BOTTOM:
+      NS_LOG_INFO ("BOTTOM");
+      yIntersect = boundaries.yMin - m_epsilon;
+      xIntersect =
+        (next.x - current.x) / (next.y - current.y) * (yIntersect - current.y) + current.x;
+      break;
+    }
+  NS_LOG_INFO ("xIntersect " << xIntersect << " yIntersect " << yIntersect);
+  return Vector (xIntersect, yIntersect, 0);
+}
+
+void
+RandomWalk2dOutdoorMobilityModel::Rebound (Time delayLeft)
+{
+  m_helper.UpdateWithBounds (m_bounds);
+  Vector position = m_helper.GetCurrentPosition ();
+  Vector speed = m_helper.GetVelocity ();
+  switch (m_bounds.GetClosestSide (position))
+    {
+    case Rectangle::RIGHT:
+    case Rectangle::LEFT:
+      speed.x = -speed.x;
+      break;
+    case Rectangle::TOP:
+    case Rectangle::BOTTOM:
+      speed.y = -speed.y;
+      break;
+    }
+  m_helper.SetVelocity (speed);
+  m_helper.Unpause ();
+  DoWalk (delayLeft);
+}
+
+void
+RandomWalk2dOutdoorMobilityModel::AvoidBuilding (Time delayLeft, Vector intersectPosition)
+{
+  m_helper.Update ();
+
+  bool nextWouldBeInside = true;
+
+  while (nextWouldBeInside)
+    {
+      double speed = m_speed->GetValue ();
+      double direction = m_direction->GetValue ();
+      Vector velocityVector (std::cos (direction) * speed,
+                             std::sin (direction) * speed,
+                             0.0);
+      m_helper.SetVelocity (velocityVector);
+
+      Vector nextPosition = intersectPosition;
+      nextPosition.x += velocityVector.x * delayLeft.GetSeconds ();
+      nextPosition.y += velocityVector.y * delayLeft.GetSeconds ();
+
+      // check if this is inside the current buildingBox
+      auto outdoorBuilding = IsLineClearOfBuildings (intersectPosition, nextPosition);
+      bool outdoor = std::get<0> (outdoorBuilding);
+
+      if (!outdoor)
+        {
+          NS_LOG_LOGIC ("inside loop intersect " << intersectPosition << " nextPosition "
+                                                 << nextPosition << " " << outdoor << " building " << std::get<1> (outdoorBuilding)->GetBoundaries ());
+        }
+      else
+        {
+          NS_LOG_LOGIC ("inside loop intersect " << intersectPosition << " nextPosition "
+                                                 << nextPosition << " " << outdoor);
+        }
+
+      if (outdoor && m_bounds.IsInside (nextPosition))
+        {
+          nextWouldBeInside = false;
+        }
+    }
+
+  m_helper.Unpause ();
+
+  DoWalk (delayLeft);
+}
+
+void
+RandomWalk2dOutdoorMobilityModel::DoDispose (void)
+{
+  // chain up
+  MobilityModel::DoDispose ();
+}
+Vector
+RandomWalk2dOutdoorMobilityModel::DoGetPosition (void) const
+{
+  m_helper.UpdateWithBounds (m_bounds);
+  return m_helper.GetCurrentPosition ();
+}
+void
+RandomWalk2dOutdoorMobilityModel::DoSetPosition (const Vector &position)
+{
+  NS_ASSERT (m_bounds.IsInside (position));
+  m_helper.SetPosition (position);
+  Simulator::Remove (m_event);
+  m_event = Simulator::ScheduleNow (&RandomWalk2dOutdoorMobilityModel::DoInitializePrivate, this);
+}
+Vector
+RandomWalk2dOutdoorMobilityModel::DoGetVelocity (void) const
+{
+  return m_helper.GetVelocity ();
+}
+int64_t
+RandomWalk2dOutdoorMobilityModel::DoAssignStreams (int64_t stream)
+{
+  m_speed->SetStream (stream);
+  m_direction->SetStream (stream + 1);
+  return 2;
+}
+
+
+} // namespace ns3
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/buildings/model/random-walk-2d-outdoor-mobility-model.h iab-psc/src/buildings/model/random-walk-2d-outdoor-mobility-model.h
--- ns3-mmwave-iab/src/buildings/model/random-walk-2d-outdoor-mobility-model.h	1970-01-01 01:00:00.000000000 +0100
+++ iab-psc/src/buildings/model/random-walk-2d-outdoor-mobility-model.h	2019-02-15 18:13:15.451798012 +0100
@@ -0,0 +1,128 @@
+/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2006,2007 INRIA
+ * Copyright (c) 2019 University of Padova
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * Author: Michele Polese <michele.polese@gmail.com>
+ */
+#ifndef RANDOM_WALK_2D_OUTDOOR_MOBILITY_MODEL_H
+#define RANDOM_WALK_2D_OUTDOOR_MOBILITY_MODEL_H
+
+#include "ns3/object.h"
+#include "ns3/nstime.h"
+#include "ns3/event-id.h"
+#include "ns3/rectangle.h"
+#include "ns3/random-variable-stream.h"
+#include "ns3/mobility-model.h"
+#include "ns3/constant-velocity-helper.h"
+#include "ns3/building.h"
+
+namespace ns3 {
+
+
+/**
+ * \ingroup mobility
+ * \brief 2D random walk mobility model which avoids buildings.
+ *
+ * This class reuses most of the code of RandomWalk2dMobilityModel,
+ * but adds the awareness of buildings objects which are avoided
+ * by moving users.
+ * Each instance moves with a speed and direction chosen at random
+ * with the user-provided random variables until
+ * either a fixed distance has been walked or until a fixed amount
+ * of time. If we hit one of the boundaries (specified by a rectangle)
+ * of the model, we rebound on the boundary with a reflexive angle
+ * and speed. If we hit one of the buildings, we rebound with a random
+ * direction which makes sure that the next step does not enter the building.
+ */
+class RandomWalk2dOutdoorMobilityModel : public MobilityModel
+{
+public:
+  /**
+   * Register this type with the TypeId system.
+   * \return the object TypeId
+   */
+  static TypeId GetTypeId (void);
+  /** An enum representing the different working modes of this module. */
+  enum Mode
+  {
+    MODE_DISTANCE,
+    MODE_TIME
+  };
+
+private:
+  /**
+   * \brief Performs the rebound of the node if it reaches a boundary
+   * \param timeLeft The remaining time of the walk
+   */
+  void Rebound (Time timeLeft);
+  /**
+   * \brief Avoid a building
+   * \param timeLeft The remaining time of the walk
+   * \param intersectPosition The position at which the building is intersected
+   */
+  void AvoidBuilding (Time delayLeft, Vector intersectPosition);
+  /**
+   * Walk according to position and velocity, until distance is reached,
+   * time is reached, or intersection with the bounding box, or building
+   */
+  void DoWalk (Time timeLeft);
+  /**
+   * Perform initialization of the object before MobilityModel::DoInitialize ()
+   */
+  void DoInitializePrivate (void);
+  /**
+   * Check if there is a building between two positions (or if the nextPosition is inside a building).
+   * The code is taken from MmWave3gppBuildingsPropagationLossModel
+   * \param currentPosition The current position of the node
+   * \param nextPosition The position to check
+   * \return a pair with a boolean (true if the line between the two position does not intersect building),
+   * and a pointer which is 0 if the boolean is true, or it points to the building which is intersected
+   */
+  std::pair<bool, Ptr<Building> > IsLineClearOfBuildings (Vector currentPosition, Vector nextPosition ) const;
+  /**
+   * Compute the intersecting point of the box represented by boundaries and the line between current and next
+   * Notice that we only consider a 2d plane
+   * \param current The current position
+   * \param next The next position
+   * \param boundaries The boundaries of the building we will intersect
+   * \return a vector with the position of the intersection
+   */
+  Vector CalculateIntersectionFromOutside (const Vector &current, const Vector &next, const Box boundaries) const;
+
+  virtual void DoDispose (void);
+  virtual void DoInitialize (void);
+  virtual Vector DoGetPosition (void) const;
+  virtual void DoSetPosition (const Vector &position);
+  virtual Vector DoGetVelocity (void) const;
+  virtual int64_t DoAssignStreams (int64_t);
+
+  ConstantVelocityHelper m_helper; //!< helper for this object
+  EventId m_event; //!< stored event ID
+  enum Mode m_mode; //!< whether in time or distance mode
+  double m_modeDistance; //!< Change direction and speed after this distance
+  Time m_modeTime; //!< Change current direction and speed after this delay
+  Ptr<RandomVariableStream> m_speed; //!< rv for picking speed
+  Ptr<RandomVariableStream> m_direction; //!< rv for picking direction
+  Rectangle m_bounds; //!< Bounds of the area to cruise
+  double m_epsilon; //!< Tolerance for the intersection point with buildings
+};
+
+
+} // namespace ns3
+
+#endif /* RANDOM_WALK_2D_OUTDOOR_MOBILITY_MODEL_H */
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/buildings/wscript iab-psc/src/buildings/wscript
--- ns3-mmwave-iab/src/buildings/wscript	2019-02-15 18:12:55.059613983 +0100
+++ iab-psc/src/buildings/wscript	2019-02-15 18:13:15.451798012 +0100
@@ -11,6 +11,8 @@
         'model/buildings-propagation-loss-model.cc',
         'model/hybrid-buildings-propagation-loss-model.cc',
         'model/oh-buildings-propagation-loss-model.cc',
+        'model/random-walk-2d-outdoor-mobility-model.cc',
+        'model/group-slave-outdoor-mobility-model.cc',
         'helper/building-container.cc',
         'helper/building-position-allocator.cc',
         'helper/building-allocator.cc',
@@ -35,6 +37,8 @@
         'model/buildings-propagation-loss-model.h',
         'model/hybrid-buildings-propagation-loss-model.h',
         'model/oh-buildings-propagation-loss-model.h',
+        'model/random-walk-2d-outdoor-mobility-model.h',
+        'model/group-slave-outdoor-mobility-model.h',
         'helper/building-container.h',
         'helper/building-allocator.h',
         'helper/building-position-allocator.h',
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/mmwave/model/mmwave-phy-mac-common.cc iab-psc/src/mmwave/model/mmwave-phy-mac-common.cc
--- ns3-mmwave-iab/src/mmwave/model/mmwave-phy-mac-common.cc	2019-02-15 18:12:55.475617727 +0100
+++ iab-psc/src/mmwave/model/mmwave-phy-mac-common.cc	2019-02-15 18:13:15.899802067 +0100
@@ -2,30 +2,30 @@
  /*
  *   Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
  *   Copyright (c) 2015, NYU WIRELESS, Tandon School of Engineering, New York University
- *   Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab. 
- *  
+ *   Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab.
+ *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License version 2 as
  *   published by the Free Software Foundation;
- *  
+ *
  *   This program is distributed in the hope that it will be useful,
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *   GNU General Public License for more details.
- *  
+ *
  *   You should have received a copy of the GNU General Public License
  *   along with this program; if not, write to the Free Software
  *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *  
+ *
  *   Author: Marco Miozzo <marco.miozzo@cttc.es>
  *           Nicola Baldo  <nbaldo@cttc.es>
- *  
+ *
  *   Modified by: Marco Mezzavilla < mezzavilla@nyu.edu>
  *        	 	  Sourjya Dutta <sdutta@nyu.edu>
  *        	 	  Russell Ford <russell.ford@nyu.edu>
  *        		  Menglei Zhang <menglei@nyu.edu>
  *
- * Modified by: Michele Polese <michele.polese@gmail.com> 
+ * Modified by: Michele Polese <michele.polese@gmail.com>
  *                 Dual Connectivity and Handover functionalities
  */
 
@@ -156,6 +156,11 @@
 									 UintegerValue (100.0),
 									 MakeUintegerAccessor (&MmWavePhyMacCommon::m_tbDecodeLatencyUs),
 									 MakeUintegerChecker<uint32_t> ())
+		 .AddAttribute ("NumRefScPerSym",
+							 "for TDMA, number of reference subcarriers across entire bandwidth (default to 1/4th of SCs)",
+							 UintegerValue (864),
+							 MakeUintegerAccessor (&MmWavePhyMacCommon::m_numRefScPerSym),
+							 MakeUintegerChecker<uint32_t> ())
 	;
 
 	return tid;
@@ -194,5 +199,3 @@
 }
 
 }
-
-
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/mobility/bindings/modulegen__gcc_ILP32.py iab-psc/src/mobility/bindings/modulegen__gcc_ILP32.py
--- ns3-mmwave-iab/src/mobility/bindings/modulegen__gcc_ILP32.py	2019-02-15 18:12:55.475617727 +0100
+++ iab-psc/src/mobility/bindings/modulegen__gcc_ILP32.py	2019-02-15 18:13:15.903802104 +0100
@@ -28,6 +28,9 @@
     module.add_class('AttributeConstructionList', import_from_module='ns.core')
     ## attribute-construction-list.h (module 'core'): ns3::AttributeConstructionList::Item [struct]
     module.add_class('Item', import_from_module='ns.core', outer_class=root_module['ns3::AttributeConstructionList'])
+    typehandlers.add_type_alias(u'std::list< ns3::AttributeConstructionList::Item > const_iterator', u'ns3::AttributeConstructionList::CIterator')
+    typehandlers.add_type_alias(u'std::list< ns3::AttributeConstructionList::Item > const_iterator*', u'ns3::AttributeConstructionList::CIterator*')
+    typehandlers.add_type_alias(u'std::list< ns3::AttributeConstructionList::Item > const_iterator&', u'ns3::AttributeConstructionList::CIterator&')
     ## box.h (module 'mobility'): ns3::Box [class]
     module.add_class('Box')
     ## box.h (module 'mobility'): ns3::Box::Side [enumeration]
@@ -90,12 +93,22 @@
     module.add_class('Ipv6Prefix', import_from_module='ns.network')
     ## mac48-address.h (module 'network'): ns3::Mac48Address [class]
     module.add_class('Mac48Address', import_from_module='ns.network')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Mac48Address )', u'ns3::Mac48Address::TracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Mac48Address )*', u'ns3::Mac48Address::TracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Mac48Address )&', u'ns3::Mac48Address::TracedCallback&')
     ## mac48-address.h (module 'network'): ns3::Mac48Address [class]
     root_module['ns3::Mac48Address'].implicitly_converts_to(root_module['ns3::Address'])
+    ## mac8-address.h (module 'network'): ns3::Mac8Address [class]
+    module.add_class('Mac8Address', import_from_module='ns.network')
+    ## mac8-address.h (module 'network'): ns3::Mac8Address [class]
+    root_module['ns3::Mac8Address'].implicitly_converts_to(root_module['ns3::Address'])
     ## mobility-helper.h (module 'mobility'): ns3::MobilityHelper [class]
     module.add_class('MobilityHelper')
     ## node-container.h (module 'network'): ns3::NodeContainer [class]
     module.add_class('NodeContainer', import_from_module='ns.network')
+    typehandlers.add_type_alias(u'std::vector< ns3::Ptr< ns3::Node > > const_iterator', u'ns3::NodeContainer::Iterator')
+    typehandlers.add_type_alias(u'std::vector< ns3::Ptr< ns3::Node > > const_iterator*', u'ns3::NodeContainer::Iterator*')
+    typehandlers.add_type_alias(u'std::vector< ns3::Ptr< ns3::Node > > const_iterator&', u'ns3::NodeContainer::Iterator&')
     ## ns2-mobility-helper.h (module 'mobility'): ns3::Ns2MobilityHelper [class]
     module.add_class('Ns2MobilityHelper')
     ## object-base.h (module 'core'): ns3::ObjectBase [class]
@@ -142,6 +155,9 @@
     module.add_class('AttributeInformation', import_from_module='ns.core', outer_class=root_module['ns3::TypeId'])
     ## type-id.h (module 'core'): ns3::TypeId::TraceSourceInformation [struct]
     module.add_class('TraceSourceInformation', import_from_module='ns.core', outer_class=root_module['ns3::TypeId'])
+    typehandlers.add_type_alias(u'uint32_t', u'ns3::TypeId::hash_t')
+    typehandlers.add_type_alias(u'uint32_t*', u'ns3::TypeId::hash_t*')
+    typehandlers.add_type_alias(u'uint32_t&', u'ns3::TypeId::hash_t&')
     ## vector.h (module 'core'): ns3::Vector2D [class]
     module.add_class('Vector2D', import_from_module='ns.core')
     ## vector.h (module 'core'): ns3::Vector3D [class]
@@ -198,6 +214,9 @@
     module.add_class('Time', import_from_module='ns.core')
     ## nstime.h (module 'core'): ns3::Time::Unit [enumeration]
     module.add_enum('Unit', ['Y', 'D', 'H', 'MIN', 'S', 'MS', 'US', 'NS', 'PS', 'FS', 'LAST'], outer_class=root_module['ns3::Time'], import_from_module='ns.core')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Time )', u'ns3::Time::TracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Time )*', u'ns3::Time::TracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Time )&', u'ns3::Time::TracedCallback&')
     ## nstime.h (module 'core'): ns3::Time [class]
     root_module['ns3::Time'].implicitly_converts_to(root_module['ns3::int64x64_t'])
     ## trace-source-accessor.h (module 'core'): ns3::TraceSourceAccessor [class]
@@ -282,14 +301,32 @@
     module.add_class('Mac48AddressValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])
     ## mobility-model.h (module 'mobility'): ns3::MobilityModel [class]
     module.add_class('MobilityModel', parent=root_module['ns3::Object'])
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::MobilityModel const > )', u'ns3::MobilityModel::TracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::MobilityModel const > )*', u'ns3::MobilityModel::TracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::MobilityModel const > )&', u'ns3::MobilityModel::TracedCallback&')
     ## net-device.h (module 'network'): ns3::NetDevice [class]
     module.add_class('NetDevice', import_from_module='ns.network', parent=root_module['ns3::Object'])
     ## net-device.h (module 'network'): ns3::NetDevice::PacketType [enumeration]
     module.add_enum('PacketType', ['PACKET_HOST', 'NS3_PACKET_HOST', 'PACKET_BROADCAST', 'NS3_PACKET_BROADCAST', 'PACKET_MULTICAST', 'NS3_PACKET_MULTICAST', 'PACKET_OTHERHOST', 'NS3_PACKET_OTHERHOST'], outer_class=root_module['ns3::NetDevice'], import_from_module='ns.network')
+    typehandlers.add_type_alias(u'void ( * ) (  )', u'ns3::NetDevice::LinkChangeTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) (  )*', u'ns3::NetDevice::LinkChangeTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) (  )&', u'ns3::NetDevice::LinkChangeTracedCallback&')
+    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::NetDevice::ReceiveCallback')
+    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::NetDevice::ReceiveCallback*')
+    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::NetDevice::ReceiveCallback&')
+    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', u'ns3::NetDevice::PromiscReceiveCallback')
+    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::NetDevice::PromiscReceiveCallback*')
+    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::NetDevice::PromiscReceiveCallback&')
     ## nix-vector.h (module 'network'): ns3::NixVector [class]
     module.add_class('NixVector', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::NixVector, ns3::empty, ns3::DefaultDeleter<ns3::NixVector> >'])
     ## node.h (module 'network'): ns3::Node [class]
     module.add_class('Node', import_from_module='ns.network', parent=root_module['ns3::Object'])
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', u'ns3::Node::ProtocolHandler')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::Node::ProtocolHandler*')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::Node::ProtocolHandler&')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::Node::DeviceAdditionListener')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::Node::DeviceAdditionListener*')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::Node::DeviceAdditionListener&')
     ## random-variable-stream.h (module 'core'): ns3::NormalRandomVariable [class]
     module.add_class('NormalRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
     ## object-factory.h (module 'core'): ns3::ObjectFactoryChecker [class]
@@ -300,6 +337,24 @@
     module.add_class('OutputStreamWrapper', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::OutputStreamWrapper, ns3::empty, ns3::DefaultDeleter<ns3::OutputStreamWrapper> >'])
     ## packet.h (module 'network'): ns3::Packet [class]
     module.add_class('Packet', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter<ns3::Packet> >'])
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > )', u'ns3::Packet::TracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > )*', u'ns3::Packet::TracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > )&', u'ns3::Packet::TracedCallback&')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Address const & )', u'ns3::Packet::AddressTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Address const & )*', u'ns3::Packet::AddressTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Address const & )&', u'ns3::Packet::AddressTracedCallback&')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > const, ns3::Address const &, ns3::Address const & )', u'ns3::Packet::TwoAddressTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > const, ns3::Address const &, ns3::Address const & )*', u'ns3::Packet::TwoAddressTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > const, ns3::Address const &, ns3::Address const & )&', u'ns3::Packet::TwoAddressTracedCallback&')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Mac48Address )', u'ns3::Packet::Mac48AddressTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Mac48Address )*', u'ns3::Packet::Mac48AddressTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Mac48Address )&', u'ns3::Packet::Mac48AddressTracedCallback&')
+    typehandlers.add_type_alias(u'void ( * ) ( uint32_t, uint32_t )', u'ns3::Packet::SizeTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( uint32_t, uint32_t )*', u'ns3::Packet::SizeTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( uint32_t, uint32_t )&', u'ns3::Packet::SizeTracedCallback&')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, double )', u'ns3::Packet::SinrTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, double )*', u'ns3::Packet::SinrTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, double )&', u'ns3::Packet::SinrTracedCallback&')
     ## random-variable-stream.h (module 'core'): ns3::ParetoRandomVariable [class]
     module.add_class('ParetoRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
     ## random-direction-2d-mobility-model.h (module 'mobility'): ns3::RandomDirection2dMobilityModel [class]
@@ -399,12 +454,12 @@
     
     ## hash-function.h (module 'core'): ns3::Hash::Implementation [class]
     module.add_class('Implementation', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::Hash::Implementation, ns3::empty, ns3::DefaultDeleter<ns3::Hash::Implementation> >'])
-    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, size_t const )', u'ns3::Hash::Hash32Function_ptr')
-    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, size_t const )*', u'ns3::Hash::Hash32Function_ptr*')
-    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, size_t const )&', u'ns3::Hash::Hash32Function_ptr&')
-    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, size_t const )', u'ns3::Hash::Hash64Function_ptr')
-    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, size_t const )*', u'ns3::Hash::Hash64Function_ptr*')
-    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, size_t const )&', u'ns3::Hash::Hash64Function_ptr&')
+    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, std::size_t const )', u'ns3::Hash::Hash32Function_ptr')
+    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, std::size_t const )*', u'ns3::Hash::Hash32Function_ptr*')
+    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, std::size_t const )&', u'ns3::Hash::Hash32Function_ptr&')
+    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, std::size_t const )', u'ns3::Hash::Hash64Function_ptr')
+    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, std::size_t const )*', u'ns3::Hash::Hash64Function_ptr*')
+    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, std::size_t const )&', u'ns3::Hash::Hash64Function_ptr&')
     
     ## Register a nested module for the namespace Function
     
@@ -462,6 +517,7 @@
     register_Ns3Ipv6Address_methods(root_module, root_module['ns3::Ipv6Address'])
     register_Ns3Ipv6Prefix_methods(root_module, root_module['ns3::Ipv6Prefix'])
     register_Ns3Mac48Address_methods(root_module, root_module['ns3::Mac48Address'])
+    register_Ns3Mac8Address_methods(root_module, root_module['ns3::Mac8Address'])
     register_Ns3MobilityHelper_methods(root_module, root_module['ns3::MobilityHelper'])
     register_Ns3NodeContainer_methods(root_module, root_module['ns3::NodeContainer'])
     register_Ns3Ns2MobilityHelper_methods(root_module, root_module['ns3::Ns2MobilityHelper'])
@@ -1334,18 +1390,18 @@
     cls.add_constructor([])
     ## hash.h (module 'core'): ns3::Hasher::Hasher(ns3::Ptr<ns3::Hash::Implementation> hp) [constructor]
     cls.add_constructor([param('ns3::Ptr< ns3::Hash::Implementation >', 'hp')])
-    ## hash.h (module 'core'): uint32_t ns3::Hasher::GetHash32(char const * buffer, size_t const size) [member function]
+    ## hash.h (module 'core'): uint32_t ns3::Hasher::GetHash32(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')])
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')])
     ## hash.h (module 'core'): uint32_t ns3::Hasher::GetHash32(std::string const s) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
                    [param('std::string const', 's')])
-    ## hash.h (module 'core'): uint64_t ns3::Hasher::GetHash64(char const * buffer, size_t const size) [member function]
+    ## hash.h (module 'core'): uint64_t ns3::Hasher::GetHash64(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash64', 
                    'uint64_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')])
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')])
     ## hash.h (module 'core'): uint64_t ns3::Hasher::GetHash64(std::string const s) [member function]
     cls.add_method('GetHash64', 
                    'uint64_t', 
@@ -1615,7 +1671,7 @@
     cls.add_method('IsAllHostsMulticast', 
                    'bool', 
                    [], 
-                   is_const=True)
+                   deprecated=True, is_const=True)
     ## ipv6-address.h (module 'network'): bool ns3::Ipv6Address::IsAllNodesMulticast() const [member function]
     cls.add_method('IsAllNodesMulticast', 
                    'bool', 
@@ -1691,6 +1747,11 @@
                    'ns3::Ipv6Address', 
                    [param('ns3::Mac64Address', 'addr'), param('ns3::Ipv6Address', 'prefix')], 
                    is_static=True)
+    ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::MakeAutoconfiguredAddress(ns3::Mac8Address addr, ns3::Ipv6Address prefix) [member function]
+    cls.add_method('MakeAutoconfiguredAddress', 
+                   'ns3::Ipv6Address', 
+                   [param('ns3::Mac8Address', 'addr'), param('ns3::Ipv6Address', 'prefix')], 
+                   is_static=True)
     ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::MakeAutoconfiguredLinkLocalAddress(ns3::Mac16Address mac) [member function]
     cls.add_method('MakeAutoconfiguredLinkLocalAddress', 
                    'ns3::Ipv6Address', 
@@ -1706,6 +1767,11 @@
                    'ns3::Ipv6Address', 
                    [param('ns3::Mac64Address', 'mac')], 
                    is_static=True)
+    ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::MakeAutoconfiguredLinkLocalAddress(ns3::Mac8Address mac) [member function]
+    cls.add_method('MakeAutoconfiguredLinkLocalAddress', 
+                   'ns3::Ipv6Address', 
+                   [param('ns3::Mac8Address', 'mac')], 
+                   is_static=True)
     ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::MakeIpv4MappedAddress(ns3::Ipv4Address addr) [member function]
     cls.add_method('MakeIpv4MappedAddress', 
                    'ns3::Ipv6Address', 
@@ -1866,6 +1932,48 @@
                    is_static=True)
     return
 
+def register_Ns3Mac8Address_methods(root_module, cls):
+    cls.add_binary_comparison_operator('<')
+    cls.add_binary_comparison_operator('==')
+    cls.add_binary_comparison_operator('!=')
+    cls.add_output_stream_operator()
+    ## mac8-address.h (module 'network'): ns3::Mac8Address::Mac8Address(ns3::Mac8Address const & arg0) [constructor]
+    cls.add_constructor([param('ns3::Mac8Address const &', 'arg0')])
+    ## mac8-address.h (module 'network'): ns3::Mac8Address::Mac8Address() [constructor]
+    cls.add_constructor([])
+    ## mac8-address.h (module 'network'): ns3::Mac8Address::Mac8Address(uint8_t addr) [constructor]
+    cls.add_constructor([param('uint8_t', 'addr')])
+    ## mac8-address.h (module 'network'): static ns3::Mac8Address ns3::Mac8Address::Allocate() [member function]
+    cls.add_method('Allocate', 
+                   'ns3::Mac8Address', 
+                   [], 
+                   is_static=True)
+    ## mac8-address.h (module 'network'): static ns3::Mac8Address ns3::Mac8Address::ConvertFrom(ns3::Address const & address) [member function]
+    cls.add_method('ConvertFrom', 
+                   'ns3::Mac8Address', 
+                   [param('ns3::Address const &', 'address')], 
+                   is_static=True)
+    ## mac8-address.h (module 'network'): void ns3::Mac8Address::CopyFrom(uint8_t const * pBuffer) [member function]
+    cls.add_method('CopyFrom', 
+                   'void', 
+                   [param('uint8_t const *', 'pBuffer')])
+    ## mac8-address.h (module 'network'): void ns3::Mac8Address::CopyTo(uint8_t * pBuffer) const [member function]
+    cls.add_method('CopyTo', 
+                   'void', 
+                   [param('uint8_t *', 'pBuffer')], 
+                   is_const=True)
+    ## mac8-address.h (module 'network'): static ns3::Mac8Address ns3::Mac8Address::GetBroadcast() [member function]
+    cls.add_method('GetBroadcast', 
+                   'ns3::Mac8Address', 
+                   [], 
+                   is_static=True)
+    ## mac8-address.h (module 'network'): static bool ns3::Mac8Address::IsMatchingType(ns3::Address const & address) [member function]
+    cls.add_method('IsMatchingType', 
+                   'bool', 
+                   [param('ns3::Address const &', 'address')], 
+                   is_static=True)
+    return
+
 def register_Ns3MobilityHelper_methods(root_module, cls):
     ## mobility-helper.h (module 'mobility'): ns3::MobilityHelper::MobilityHelper(ns3::MobilityHelper const & arg0) [constructor]
     cls.add_constructor([param('ns3::MobilityHelper const &', 'arg0')])
@@ -1979,6 +2087,11 @@
                    'ns3::NodeContainer::Iterator', 
                    [], 
                    is_const=True)
+    ## node-container.h (module 'network'): bool ns3::NodeContainer::Contains(uint32_t id) const [member function]
+    cls.add_method('Contains', 
+                   'bool', 
+                   [param('uint32_t', 'id')], 
+                   is_const=True)
     ## node-container.h (module 'network'): void ns3::NodeContainer::Create(uint32_t n) [member function]
     cls.add_method('Create', 
                    'void', 
@@ -2490,24 +2603,25 @@
     ## type-id.h (module 'core'): ns3::TypeId ns3::TypeId::AddTraceSource(std::string name, std::string help, ns3::Ptr<const ns3::TraceSourceAccessor> accessor) [member function]
     cls.add_method('AddTraceSource', 
                    'ns3::TypeId', 
-                   [param('std::string', 'name'), param('std::string', 'help'), param('ns3::Ptr< ns3::TraceSourceAccessor const >', 'accessor')])
+                   [param('std::string', 'name'), param('std::string', 'help'), param('ns3::Ptr< ns3::TraceSourceAccessor const >', 'accessor')], 
+                   deprecated=True)
     ## type-id.h (module 'core'): ns3::TypeId ns3::TypeId::AddTraceSource(std::string name, std::string help, ns3::Ptr<const ns3::TraceSourceAccessor> accessor, std::string callback, ns3::TypeId::SupportLevel supportLevel=::ns3::TypeId::SupportLevel::SUPPORTED, std::string const & supportMsg="") [member function]
     cls.add_method('AddTraceSource', 
                    'ns3::TypeId', 
                    [param('std::string', 'name'), param('std::string', 'help'), param('ns3::Ptr< ns3::TraceSourceAccessor const >', 'accessor'), param('std::string', 'callback'), param('ns3::TypeId::SupportLevel', 'supportLevel', default_value='::ns3::TypeId::SupportLevel::SUPPORTED'), param('std::string const &', 'supportMsg', default_value='""')])
-    ## type-id.h (module 'core'): ns3::TypeId::AttributeInformation ns3::TypeId::GetAttribute(uint32_t i) const [member function]
+    ## type-id.h (module 'core'): ns3::TypeId::AttributeInformation ns3::TypeId::GetAttribute(std::size_t i) const [member function]
     cls.add_method('GetAttribute', 
                    'ns3::TypeId::AttributeInformation', 
-                   [param('uint32_t', 'i')], 
+                   [param('std::size_t', 'i')], 
                    is_const=True)
-    ## type-id.h (module 'core'): std::string ns3::TypeId::GetAttributeFullName(uint32_t i) const [member function]
+    ## type-id.h (module 'core'): std::string ns3::TypeId::GetAttributeFullName(std::size_t i) const [member function]
     cls.add_method('GetAttributeFullName', 
                    'std::string', 
-                   [param('uint32_t', 'i')], 
+                   [param('std::size_t', 'i')], 
                    is_const=True)
-    ## type-id.h (module 'core'): uint32_t ns3::TypeId::GetAttributeN() const [member function]
+    ## type-id.h (module 'core'): std::size_t ns3::TypeId::GetAttributeN() const [member function]
     cls.add_method('GetAttributeN', 
-                   'uint32_t', 
+                   'std::size_t', 
                    [], 
                    is_const=True)
     ## type-id.h (module 'core'): ns3::Callback<ns3::ObjectBase *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> ns3::TypeId::GetConstructor() const [member function]
@@ -2535,14 +2649,14 @@
                    'ns3::TypeId', 
                    [], 
                    is_const=True)
-    ## type-id.h (module 'core'): static ns3::TypeId ns3::TypeId::GetRegistered(uint32_t i) [member function]
+    ## type-id.h (module 'core'): static ns3::TypeId ns3::TypeId::GetRegistered(uint16_t i) [member function]
     cls.add_method('GetRegistered', 
                    'ns3::TypeId', 
-                   [param('uint32_t', 'i')], 
+                   [param('uint16_t', 'i')], 
                    is_static=True)
-    ## type-id.h (module 'core'): static uint32_t ns3::TypeId::GetRegisteredN() [member function]
+    ## type-id.h (module 'core'): static uint16_t ns3::TypeId::GetRegisteredN() [member function]
     cls.add_method('GetRegisteredN', 
-                   'uint32_t', 
+                   'uint16_t', 
                    [], 
                    is_static=True)
     ## type-id.h (module 'core'): std::size_t ns3::TypeId::GetSize() const [member function]
@@ -2550,14 +2664,14 @@
                    'std::size_t', 
                    [], 
                    is_const=True)
-    ## type-id.h (module 'core'): ns3::TypeId::TraceSourceInformation ns3::TypeId::GetTraceSource(uint32_t i) const [member function]
+    ## type-id.h (module 'core'): ns3::TypeId::TraceSourceInformation ns3::TypeId::GetTraceSource(std::size_t i) const [member function]
     cls.add_method('GetTraceSource', 
                    'ns3::TypeId::TraceSourceInformation', 
-                   [param('uint32_t', 'i')], 
+                   [param('std::size_t', 'i')], 
                    is_const=True)
-    ## type-id.h (module 'core'): uint32_t ns3::TypeId::GetTraceSourceN() const [member function]
+    ## type-id.h (module 'core'): std::size_t ns3::TypeId::GetTraceSourceN() const [member function]
     cls.add_method('GetTraceSourceN', 
-                   'uint32_t', 
+                   'std::size_t', 
                    [], 
                    is_const=True)
     ## type-id.h (module 'core'): uint16_t ns3::TypeId::GetUid() const [member function]
@@ -2619,10 +2733,10 @@
                    'bool', 
                    [], 
                    is_const=True)
-    ## type-id.h (module 'core'): bool ns3::TypeId::SetAttributeInitialValue(uint32_t i, ns3::Ptr<const ns3::AttributeValue> initialValue) [member function]
+    ## type-id.h (module 'core'): bool ns3::TypeId::SetAttributeInitialValue(std::size_t i, ns3::Ptr<const ns3::AttributeValue> initialValue) [member function]
     cls.add_method('SetAttributeInitialValue', 
                    'bool', 
-                   [param('uint32_t', 'i'), param('ns3::Ptr< ns3::AttributeValue const >', 'initialValue')])
+                   [param('std::size_t', 'i'), param('ns3::Ptr< ns3::AttributeValue const >', 'initialValue')])
     ## type-id.h (module 'core'): ns3::TypeId ns3::TypeId::SetGroupName(std::string groupName) [member function]
     cls.add_method('SetGroupName', 
                    'ns3::TypeId', 
@@ -2828,6 +2942,11 @@
                    'uint32_t', 
                    [param('ns3::Buffer::Iterator', 'start')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## chunk.h (module 'network'): uint32_t ns3::Chunk::Deserialize(ns3::Buffer::Iterator start, ns3::Buffer::Iterator end) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start'), param('ns3::Buffer::Iterator', 'end')], 
+                   is_virtual=True)
     ## chunk.h (module 'network'): static ns3::TypeId ns3::Chunk::GetTypeId() [member function]
     cls.add_method('GetTypeId', 
                    'ns3::TypeId', 
@@ -3457,6 +3576,11 @@
                    'uint32_t', 
                    [param('ns3::Buffer::Iterator', 'end')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## trailer.h (module 'network'): uint32_t ns3::Trailer::Deserialize(ns3::Buffer::Iterator start, ns3::Buffer::Iterator end) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start'), param('ns3::Buffer::Iterator', 'end')], 
+                   is_virtual=True)
     ## trailer.h (module 'network'): uint32_t ns3::Trailer::GetSerializedSize() const [member function]
     cls.add_method('GetSerializedSize', 
                    'uint32_t', 
@@ -3977,10 +4101,10 @@
                    is_static=True)
     ## random-variable-stream.h (module 'core'): ns3::DeterministicRandomVariable::DeterministicRandomVariable() [constructor]
     cls.add_constructor([])
-    ## random-variable-stream.h (module 'core'): void ns3::DeterministicRandomVariable::SetValueArray(double * values, uint64_t length) [member function]
+    ## random-variable-stream.h (module 'core'): void ns3::DeterministicRandomVariable::SetValueArray(double * values, std::size_t length) [member function]
     cls.add_method('SetValueArray', 
                    'void', 
-                   [param('double *', 'values'), param('uint64_t', 'length')])
+                   [param('double *', 'values'), param('std::size_t', 'length')])
     ## random-variable-stream.h (module 'core'): double ns3::DeterministicRandomVariable::GetValue() [member function]
     cls.add_method('GetValue', 
                    'double', 
@@ -5136,6 +5260,11 @@
                    'uint32_t', 
                    [param('ns3::Header &', 'header')], 
                    is_const=True)
+    ## packet.h (module 'network'): uint32_t ns3::Packet::PeekHeader(ns3::Header & header, uint32_t size) const [member function]
+    cls.add_method('PeekHeader', 
+                   'uint32_t', 
+                   [param('ns3::Header &', 'header'), param('uint32_t', 'size')], 
+                   is_const=True)
     ## packet.h (module 'network'): bool ns3::Packet::PeekPacketTag(ns3::Tag & tag) const [member function]
     cls.add_method('PeekPacketTag', 
                    'bool', 
@@ -5180,6 +5309,10 @@
     cls.add_method('RemoveHeader', 
                    'uint32_t', 
                    [param('ns3::Header &', 'header')])
+    ## packet.h (module 'network'): uint32_t ns3::Packet::RemoveHeader(ns3::Header & header, uint32_t size) [member function]
+    cls.add_method('RemoveHeader', 
+                   'uint32_t', 
+                   [param('ns3::Header &', 'header'), param('uint32_t', 'size')])
     ## packet.h (module 'network'): bool ns3::Packet::RemovePacketTag(ns3::Tag & tag) [member function]
     cls.add_method('RemovePacketTag', 
                    'bool', 
@@ -5220,7 +5353,7 @@
     cls.add_method('GetMean', 
                    'double', 
                    [], 
-                   is_const=True)
+                   deprecated=True, is_const=True)
     ## random-variable-stream.h (module 'core'): double ns3::ParetoRandomVariable::GetScale() const [member function]
     cls.add_method('GetScale', 
                    'double', 
@@ -6006,15 +6139,15 @@
     cls.add_constructor([param('ns3::Hash::Implementation const &', 'arg0')])
     ## hash-function.h (module 'core'): ns3::Hash::Implementation::Implementation() [constructor]
     cls.add_constructor([])
-    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Implementation::GetHash32(char const * buffer, size_t const size) [member function]
+    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Implementation::GetHash32(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_pure_virtual=True, is_virtual=True)
-    ## hash-function.h (module 'core'): uint64_t ns3::Hash::Implementation::GetHash64(char const * buffer, size_t const size) [member function]
+    ## hash-function.h (module 'core'): uint64_t ns3::Hash::Implementation::GetHash64(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash64', 
                    'uint64_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_virtual=True)
     ## hash-function.h (module 'core'): void ns3::Hash::Implementation::clear() [member function]
     cls.add_method('clear', 
@@ -6050,10 +6183,10 @@
     cls.add_constructor([param('ns3::Hash::Function::Hash32 const &', 'arg0')])
     ## hash-function.h (module 'core'): ns3::Hash::Function::Hash32::Hash32(ns3::Hash::Hash32Function_ptr hp) [constructor]
     cls.add_constructor([param('ns3::Hash::Hash32Function_ptr', 'hp')])
-    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Function::Hash32::GetHash32(char const * buffer, size_t const size) [member function]
+    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Function::Hash32::GetHash32(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_virtual=True)
     ## hash-function.h (module 'core'): void ns3::Hash::Function::Hash32::clear() [member function]
     cls.add_method('clear', 
@@ -6067,15 +6200,15 @@
     cls.add_constructor([param('ns3::Hash::Function::Hash64 const &', 'arg0')])
     ## hash-function.h (module 'core'): ns3::Hash::Function::Hash64::Hash64(ns3::Hash::Hash64Function_ptr hp) [constructor]
     cls.add_constructor([param('ns3::Hash::Hash64Function_ptr', 'hp')])
-    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Function::Hash64::GetHash32(char const * buffer, size_t const size) [member function]
+    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Function::Hash64::GetHash32(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_virtual=True)
-    ## hash-function.h (module 'core'): uint64_t ns3::Hash::Function::Hash64::GetHash64(char const * buffer, size_t const size) [member function]
+    ## hash-function.h (module 'core'): uint64_t ns3::Hash::Function::Hash64::GetHash64(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash64', 
                    'uint64_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_virtual=True)
     ## hash-function.h (module 'core'): void ns3::Hash::Function::Hash64::clear() [member function]
     cls.add_method('clear', 
@@ -6089,15 +6222,15 @@
     cls.add_constructor([param('ns3::Hash::Function::Murmur3 const &', 'arg0')])
     ## hash-murmur3.h (module 'core'): ns3::Hash::Function::Murmur3::Murmur3() [constructor]
     cls.add_constructor([])
-    ## hash-murmur3.h (module 'core'): uint32_t ns3::Hash::Function::Murmur3::GetHash32(char const * buffer, size_t const size) [member function]
+    ## hash-murmur3.h (module 'core'): uint32_t ns3::Hash::Function::Murmur3::GetHash32(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_virtual=True)
-    ## hash-murmur3.h (module 'core'): uint64_t ns3::Hash::Function::Murmur3::GetHash64(char const * buffer, size_t const size) [member function]
+    ## hash-murmur3.h (module 'core'): uint64_t ns3::Hash::Function::Murmur3::GetHash64(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash64', 
                    'uint64_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_virtual=True)
     ## hash-murmur3.h (module 'core'): void ns3::Hash::Function::Murmur3::clear() [member function]
     cls.add_method('clear', 
@@ -6120,16 +6253,16 @@
     module.add_function('MakeWaypointChecker', 
                         'ns3::Ptr< ns3::AttributeChecker const >', 
                         [])
-    register_functions_ns3_FatalImpl(module.get_submodule('FatalImpl'), root_module)
-    register_functions_ns3_Hash(module.get_submodule('Hash'), root_module)
-    register_functions_ns3_TracedValueCallback(module.get_submodule('TracedValueCallback'), root_module)
+    register_functions_ns3_FatalImpl(module.add_cpp_namespace('FatalImpl'), root_module)
+    register_functions_ns3_Hash(module.add_cpp_namespace('Hash'), root_module)
+    register_functions_ns3_TracedValueCallback(module.add_cpp_namespace('TracedValueCallback'), root_module)
     return
 
 def register_functions_ns3_FatalImpl(module, root_module):
     return
 
 def register_functions_ns3_Hash(module, root_module):
-    register_functions_ns3_Hash_Function(module.get_submodule('Function'), root_module)
+    register_functions_ns3_Hash_Function(module.add_cpp_namespace('Function'), root_module)
     return
 
 def register_functions_ns3_Hash_Function(module, root_module):
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/mobility/bindings/modulegen__gcc_LP64.py iab-psc/src/mobility/bindings/modulegen__gcc_LP64.py
--- ns3-mmwave-iab/src/mobility/bindings/modulegen__gcc_LP64.py	2019-02-15 18:12:55.475617727 +0100
+++ iab-psc/src/mobility/bindings/modulegen__gcc_LP64.py	2019-02-15 18:13:15.907802139 +0100
@@ -28,6 +28,9 @@
     module.add_class('AttributeConstructionList', import_from_module='ns.core')
     ## attribute-construction-list.h (module 'core'): ns3::AttributeConstructionList::Item [struct]
     module.add_class('Item', import_from_module='ns.core', outer_class=root_module['ns3::AttributeConstructionList'])
+    typehandlers.add_type_alias(u'std::list< ns3::AttributeConstructionList::Item > const_iterator', u'ns3::AttributeConstructionList::CIterator')
+    typehandlers.add_type_alias(u'std::list< ns3::AttributeConstructionList::Item > const_iterator*', u'ns3::AttributeConstructionList::CIterator*')
+    typehandlers.add_type_alias(u'std::list< ns3::AttributeConstructionList::Item > const_iterator&', u'ns3::AttributeConstructionList::CIterator&')
     ## box.h (module 'mobility'): ns3::Box [class]
     module.add_class('Box')
     ## box.h (module 'mobility'): ns3::Box::Side [enumeration]
@@ -90,12 +93,22 @@
     module.add_class('Ipv6Prefix', import_from_module='ns.network')
     ## mac48-address.h (module 'network'): ns3::Mac48Address [class]
     module.add_class('Mac48Address', import_from_module='ns.network')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Mac48Address )', u'ns3::Mac48Address::TracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Mac48Address )*', u'ns3::Mac48Address::TracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Mac48Address )&', u'ns3::Mac48Address::TracedCallback&')
     ## mac48-address.h (module 'network'): ns3::Mac48Address [class]
     root_module['ns3::Mac48Address'].implicitly_converts_to(root_module['ns3::Address'])
+    ## mac8-address.h (module 'network'): ns3::Mac8Address [class]
+    module.add_class('Mac8Address', import_from_module='ns.network')
+    ## mac8-address.h (module 'network'): ns3::Mac8Address [class]
+    root_module['ns3::Mac8Address'].implicitly_converts_to(root_module['ns3::Address'])
     ## mobility-helper.h (module 'mobility'): ns3::MobilityHelper [class]
     module.add_class('MobilityHelper')
     ## node-container.h (module 'network'): ns3::NodeContainer [class]
     module.add_class('NodeContainer', import_from_module='ns.network')
+    typehandlers.add_type_alias(u'std::vector< ns3::Ptr< ns3::Node > > const_iterator', u'ns3::NodeContainer::Iterator')
+    typehandlers.add_type_alias(u'std::vector< ns3::Ptr< ns3::Node > > const_iterator*', u'ns3::NodeContainer::Iterator*')
+    typehandlers.add_type_alias(u'std::vector< ns3::Ptr< ns3::Node > > const_iterator&', u'ns3::NodeContainer::Iterator&')
     ## ns2-mobility-helper.h (module 'mobility'): ns3::Ns2MobilityHelper [class]
     module.add_class('Ns2MobilityHelper')
     ## object-base.h (module 'core'): ns3::ObjectBase [class]
@@ -142,6 +155,9 @@
     module.add_class('AttributeInformation', import_from_module='ns.core', outer_class=root_module['ns3::TypeId'])
     ## type-id.h (module 'core'): ns3::TypeId::TraceSourceInformation [struct]
     module.add_class('TraceSourceInformation', import_from_module='ns.core', outer_class=root_module['ns3::TypeId'])
+    typehandlers.add_type_alias(u'uint32_t', u'ns3::TypeId::hash_t')
+    typehandlers.add_type_alias(u'uint32_t*', u'ns3::TypeId::hash_t*')
+    typehandlers.add_type_alias(u'uint32_t&', u'ns3::TypeId::hash_t&')
     ## vector.h (module 'core'): ns3::Vector2D [class]
     module.add_class('Vector2D', import_from_module='ns.core')
     ## vector.h (module 'core'): ns3::Vector3D [class]
@@ -198,6 +214,9 @@
     module.add_class('Time', import_from_module='ns.core')
     ## nstime.h (module 'core'): ns3::Time::Unit [enumeration]
     module.add_enum('Unit', ['Y', 'D', 'H', 'MIN', 'S', 'MS', 'US', 'NS', 'PS', 'FS', 'LAST'], outer_class=root_module['ns3::Time'], import_from_module='ns.core')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Time )', u'ns3::Time::TracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Time )*', u'ns3::Time::TracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Time )&', u'ns3::Time::TracedCallback&')
     ## nstime.h (module 'core'): ns3::Time [class]
     root_module['ns3::Time'].implicitly_converts_to(root_module['ns3::int64x64_t'])
     ## trace-source-accessor.h (module 'core'): ns3::TraceSourceAccessor [class]
@@ -282,14 +301,32 @@
     module.add_class('Mac48AddressValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])
     ## mobility-model.h (module 'mobility'): ns3::MobilityModel [class]
     module.add_class('MobilityModel', parent=root_module['ns3::Object'])
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::MobilityModel const > )', u'ns3::MobilityModel::TracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::MobilityModel const > )*', u'ns3::MobilityModel::TracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::MobilityModel const > )&', u'ns3::MobilityModel::TracedCallback&')
     ## net-device.h (module 'network'): ns3::NetDevice [class]
     module.add_class('NetDevice', import_from_module='ns.network', parent=root_module['ns3::Object'])
     ## net-device.h (module 'network'): ns3::NetDevice::PacketType [enumeration]
     module.add_enum('PacketType', ['PACKET_HOST', 'NS3_PACKET_HOST', 'PACKET_BROADCAST', 'NS3_PACKET_BROADCAST', 'PACKET_MULTICAST', 'NS3_PACKET_MULTICAST', 'PACKET_OTHERHOST', 'NS3_PACKET_OTHERHOST'], outer_class=root_module['ns3::NetDevice'], import_from_module='ns.network')
+    typehandlers.add_type_alias(u'void ( * ) (  )', u'ns3::NetDevice::LinkChangeTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) (  )*', u'ns3::NetDevice::LinkChangeTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) (  )&', u'ns3::NetDevice::LinkChangeTracedCallback&')
+    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::NetDevice::ReceiveCallback')
+    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::NetDevice::ReceiveCallback*')
+    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::NetDevice::ReceiveCallback&')
+    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', u'ns3::NetDevice::PromiscReceiveCallback')
+    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::NetDevice::PromiscReceiveCallback*')
+    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::NetDevice::PromiscReceiveCallback&')
     ## nix-vector.h (module 'network'): ns3::NixVector [class]
     module.add_class('NixVector', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::NixVector, ns3::empty, ns3::DefaultDeleter<ns3::NixVector> >'])
     ## node.h (module 'network'): ns3::Node [class]
     module.add_class('Node', import_from_module='ns.network', parent=root_module['ns3::Object'])
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', u'ns3::Node::ProtocolHandler')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::Node::ProtocolHandler*')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::Node::ProtocolHandler&')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::Node::DeviceAdditionListener')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::Node::DeviceAdditionListener*')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::Node::DeviceAdditionListener&')
     ## random-variable-stream.h (module 'core'): ns3::NormalRandomVariable [class]
     module.add_class('NormalRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
     ## object-factory.h (module 'core'): ns3::ObjectFactoryChecker [class]
@@ -300,6 +337,24 @@
     module.add_class('OutputStreamWrapper', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::OutputStreamWrapper, ns3::empty, ns3::DefaultDeleter<ns3::OutputStreamWrapper> >'])
     ## packet.h (module 'network'): ns3::Packet [class]
     module.add_class('Packet', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter<ns3::Packet> >'])
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > )', u'ns3::Packet::TracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > )*', u'ns3::Packet::TracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > )&', u'ns3::Packet::TracedCallback&')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Address const & )', u'ns3::Packet::AddressTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Address const & )*', u'ns3::Packet::AddressTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Address const & )&', u'ns3::Packet::AddressTracedCallback&')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > const, ns3::Address const &, ns3::Address const & )', u'ns3::Packet::TwoAddressTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > const, ns3::Address const &, ns3::Address const & )*', u'ns3::Packet::TwoAddressTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const > const, ns3::Address const &, ns3::Address const & )&', u'ns3::Packet::TwoAddressTracedCallback&')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Mac48Address )', u'ns3::Packet::Mac48AddressTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Mac48Address )*', u'ns3::Packet::Mac48AddressTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, ns3::Mac48Address )&', u'ns3::Packet::Mac48AddressTracedCallback&')
+    typehandlers.add_type_alias(u'void ( * ) ( uint32_t, uint32_t )', u'ns3::Packet::SizeTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( uint32_t, uint32_t )*', u'ns3::Packet::SizeTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( uint32_t, uint32_t )&', u'ns3::Packet::SizeTracedCallback&')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, double )', u'ns3::Packet::SinrTracedCallback')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, double )*', u'ns3::Packet::SinrTracedCallback*')
+    typehandlers.add_type_alias(u'void ( * ) ( ns3::Ptr< ns3::Packet const >, double )&', u'ns3::Packet::SinrTracedCallback&')
     ## random-variable-stream.h (module 'core'): ns3::ParetoRandomVariable [class]
     module.add_class('ParetoRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
     ## random-direction-2d-mobility-model.h (module 'mobility'): ns3::RandomDirection2dMobilityModel [class]
@@ -399,12 +454,12 @@
     
     ## hash-function.h (module 'core'): ns3::Hash::Implementation [class]
     module.add_class('Implementation', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::Hash::Implementation, ns3::empty, ns3::DefaultDeleter<ns3::Hash::Implementation> >'])
-    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, size_t const )', u'ns3::Hash::Hash32Function_ptr')
-    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, size_t const )*', u'ns3::Hash::Hash32Function_ptr*')
-    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, size_t const )&', u'ns3::Hash::Hash32Function_ptr&')
-    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, size_t const )', u'ns3::Hash::Hash64Function_ptr')
-    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, size_t const )*', u'ns3::Hash::Hash64Function_ptr*')
-    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, size_t const )&', u'ns3::Hash::Hash64Function_ptr&')
+    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, std::size_t const )', u'ns3::Hash::Hash32Function_ptr')
+    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, std::size_t const )*', u'ns3::Hash::Hash32Function_ptr*')
+    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, std::size_t const )&', u'ns3::Hash::Hash32Function_ptr&')
+    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, std::size_t const )', u'ns3::Hash::Hash64Function_ptr')
+    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, std::size_t const )*', u'ns3::Hash::Hash64Function_ptr*')
+    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, std::size_t const )&', u'ns3::Hash::Hash64Function_ptr&')
     
     ## Register a nested module for the namespace Function
     
@@ -462,6 +517,7 @@
     register_Ns3Ipv6Address_methods(root_module, root_module['ns3::Ipv6Address'])
     register_Ns3Ipv6Prefix_methods(root_module, root_module['ns3::Ipv6Prefix'])
     register_Ns3Mac48Address_methods(root_module, root_module['ns3::Mac48Address'])
+    register_Ns3Mac8Address_methods(root_module, root_module['ns3::Mac8Address'])
     register_Ns3MobilityHelper_methods(root_module, root_module['ns3::MobilityHelper'])
     register_Ns3NodeContainer_methods(root_module, root_module['ns3::NodeContainer'])
     register_Ns3Ns2MobilityHelper_methods(root_module, root_module['ns3::Ns2MobilityHelper'])
@@ -1334,18 +1390,18 @@
     cls.add_constructor([])
     ## hash.h (module 'core'): ns3::Hasher::Hasher(ns3::Ptr<ns3::Hash::Implementation> hp) [constructor]
     cls.add_constructor([param('ns3::Ptr< ns3::Hash::Implementation >', 'hp')])
-    ## hash.h (module 'core'): uint32_t ns3::Hasher::GetHash32(char const * buffer, size_t const size) [member function]
+    ## hash.h (module 'core'): uint32_t ns3::Hasher::GetHash32(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')])
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')])
     ## hash.h (module 'core'): uint32_t ns3::Hasher::GetHash32(std::string const s) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
                    [param('std::string const', 's')])
-    ## hash.h (module 'core'): uint64_t ns3::Hasher::GetHash64(char const * buffer, size_t const size) [member function]
+    ## hash.h (module 'core'): uint64_t ns3::Hasher::GetHash64(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash64', 
                    'uint64_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')])
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')])
     ## hash.h (module 'core'): uint64_t ns3::Hasher::GetHash64(std::string const s) [member function]
     cls.add_method('GetHash64', 
                    'uint64_t', 
@@ -1615,7 +1671,7 @@
     cls.add_method('IsAllHostsMulticast', 
                    'bool', 
                    [], 
-                   is_const=True)
+                   deprecated=True, is_const=True)
     ## ipv6-address.h (module 'network'): bool ns3::Ipv6Address::IsAllNodesMulticast() const [member function]
     cls.add_method('IsAllNodesMulticast', 
                    'bool', 
@@ -1691,6 +1747,11 @@
                    'ns3::Ipv6Address', 
                    [param('ns3::Mac64Address', 'addr'), param('ns3::Ipv6Address', 'prefix')], 
                    is_static=True)
+    ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::MakeAutoconfiguredAddress(ns3::Mac8Address addr, ns3::Ipv6Address prefix) [member function]
+    cls.add_method('MakeAutoconfiguredAddress', 
+                   'ns3::Ipv6Address', 
+                   [param('ns3::Mac8Address', 'addr'), param('ns3::Ipv6Address', 'prefix')], 
+                   is_static=True)
     ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::MakeAutoconfiguredLinkLocalAddress(ns3::Mac16Address mac) [member function]
     cls.add_method('MakeAutoconfiguredLinkLocalAddress', 
                    'ns3::Ipv6Address', 
@@ -1706,6 +1767,11 @@
                    'ns3::Ipv6Address', 
                    [param('ns3::Mac64Address', 'mac')], 
                    is_static=True)
+    ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::MakeAutoconfiguredLinkLocalAddress(ns3::Mac8Address mac) [member function]
+    cls.add_method('MakeAutoconfiguredLinkLocalAddress', 
+                   'ns3::Ipv6Address', 
+                   [param('ns3::Mac8Address', 'mac')], 
+                   is_static=True)
     ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::MakeIpv4MappedAddress(ns3::Ipv4Address addr) [member function]
     cls.add_method('MakeIpv4MappedAddress', 
                    'ns3::Ipv6Address', 
@@ -1866,6 +1932,48 @@
                    is_static=True)
     return
 
+def register_Ns3Mac8Address_methods(root_module, cls):
+    cls.add_binary_comparison_operator('<')
+    cls.add_binary_comparison_operator('==')
+    cls.add_binary_comparison_operator('!=')
+    cls.add_output_stream_operator()
+    ## mac8-address.h (module 'network'): ns3::Mac8Address::Mac8Address(ns3::Mac8Address const & arg0) [constructor]
+    cls.add_constructor([param('ns3::Mac8Address const &', 'arg0')])
+    ## mac8-address.h (module 'network'): ns3::Mac8Address::Mac8Address() [constructor]
+    cls.add_constructor([])
+    ## mac8-address.h (module 'network'): ns3::Mac8Address::Mac8Address(uint8_t addr) [constructor]
+    cls.add_constructor([param('uint8_t', 'addr')])
+    ## mac8-address.h (module 'network'): static ns3::Mac8Address ns3::Mac8Address::Allocate() [member function]
+    cls.add_method('Allocate', 
+                   'ns3::Mac8Address', 
+                   [], 
+                   is_static=True)
+    ## mac8-address.h (module 'network'): static ns3::Mac8Address ns3::Mac8Address::ConvertFrom(ns3::Address const & address) [member function]
+    cls.add_method('ConvertFrom', 
+                   'ns3::Mac8Address', 
+                   [param('ns3::Address const &', 'address')], 
+                   is_static=True)
+    ## mac8-address.h (module 'network'): void ns3::Mac8Address::CopyFrom(uint8_t const * pBuffer) [member function]
+    cls.add_method('CopyFrom', 
+                   'void', 
+                   [param('uint8_t const *', 'pBuffer')])
+    ## mac8-address.h (module 'network'): void ns3::Mac8Address::CopyTo(uint8_t * pBuffer) const [member function]
+    cls.add_method('CopyTo', 
+                   'void', 
+                   [param('uint8_t *', 'pBuffer')], 
+                   is_const=True)
+    ## mac8-address.h (module 'network'): static ns3::Mac8Address ns3::Mac8Address::GetBroadcast() [member function]
+    cls.add_method('GetBroadcast', 
+                   'ns3::Mac8Address', 
+                   [], 
+                   is_static=True)
+    ## mac8-address.h (module 'network'): static bool ns3::Mac8Address::IsMatchingType(ns3::Address const & address) [member function]
+    cls.add_method('IsMatchingType', 
+                   'bool', 
+                   [param('ns3::Address const &', 'address')], 
+                   is_static=True)
+    return
+
 def register_Ns3MobilityHelper_methods(root_module, cls):
     ## mobility-helper.h (module 'mobility'): ns3::MobilityHelper::MobilityHelper(ns3::MobilityHelper const & arg0) [constructor]
     cls.add_constructor([param('ns3::MobilityHelper const &', 'arg0')])
@@ -1979,6 +2087,11 @@
                    'ns3::NodeContainer::Iterator', 
                    [], 
                    is_const=True)
+    ## node-container.h (module 'network'): bool ns3::NodeContainer::Contains(uint32_t id) const [member function]
+    cls.add_method('Contains', 
+                   'bool', 
+                   [param('uint32_t', 'id')], 
+                   is_const=True)
     ## node-container.h (module 'network'): void ns3::NodeContainer::Create(uint32_t n) [member function]
     cls.add_method('Create', 
                    'void', 
@@ -2490,24 +2603,25 @@
     ## type-id.h (module 'core'): ns3::TypeId ns3::TypeId::AddTraceSource(std::string name, std::string help, ns3::Ptr<const ns3::TraceSourceAccessor> accessor) [member function]
     cls.add_method('AddTraceSource', 
                    'ns3::TypeId', 
-                   [param('std::string', 'name'), param('std::string', 'help'), param('ns3::Ptr< ns3::TraceSourceAccessor const >', 'accessor')])
+                   [param('std::string', 'name'), param('std::string', 'help'), param('ns3::Ptr< ns3::TraceSourceAccessor const >', 'accessor')], 
+                   deprecated=True)
     ## type-id.h (module 'core'): ns3::TypeId ns3::TypeId::AddTraceSource(std::string name, std::string help, ns3::Ptr<const ns3::TraceSourceAccessor> accessor, std::string callback, ns3::TypeId::SupportLevel supportLevel=::ns3::TypeId::SupportLevel::SUPPORTED, std::string const & supportMsg="") [member function]
     cls.add_method('AddTraceSource', 
                    'ns3::TypeId', 
                    [param('std::string', 'name'), param('std::string', 'help'), param('ns3::Ptr< ns3::TraceSourceAccessor const >', 'accessor'), param('std::string', 'callback'), param('ns3::TypeId::SupportLevel', 'supportLevel', default_value='::ns3::TypeId::SupportLevel::SUPPORTED'), param('std::string const &', 'supportMsg', default_value='""')])
-    ## type-id.h (module 'core'): ns3::TypeId::AttributeInformation ns3::TypeId::GetAttribute(uint32_t i) const [member function]
+    ## type-id.h (module 'core'): ns3::TypeId::AttributeInformation ns3::TypeId::GetAttribute(std::size_t i) const [member function]
     cls.add_method('GetAttribute', 
                    'ns3::TypeId::AttributeInformation', 
-                   [param('uint32_t', 'i')], 
+                   [param('std::size_t', 'i')], 
                    is_const=True)
-    ## type-id.h (module 'core'): std::string ns3::TypeId::GetAttributeFullName(uint32_t i) const [member function]
+    ## type-id.h (module 'core'): std::string ns3::TypeId::GetAttributeFullName(std::size_t i) const [member function]
     cls.add_method('GetAttributeFullName', 
                    'std::string', 
-                   [param('uint32_t', 'i')], 
+                   [param('std::size_t', 'i')], 
                    is_const=True)
-    ## type-id.h (module 'core'): uint32_t ns3::TypeId::GetAttributeN() const [member function]
+    ## type-id.h (module 'core'): std::size_t ns3::TypeId::GetAttributeN() const [member function]
     cls.add_method('GetAttributeN', 
-                   'uint32_t', 
+                   'std::size_t', 
                    [], 
                    is_const=True)
     ## type-id.h (module 'core'): ns3::Callback<ns3::ObjectBase *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> ns3::TypeId::GetConstructor() const [member function]
@@ -2535,14 +2649,14 @@
                    'ns3::TypeId', 
                    [], 
                    is_const=True)
-    ## type-id.h (module 'core'): static ns3::TypeId ns3::TypeId::GetRegistered(uint32_t i) [member function]
+    ## type-id.h (module 'core'): static ns3::TypeId ns3::TypeId::GetRegistered(uint16_t i) [member function]
     cls.add_method('GetRegistered', 
                    'ns3::TypeId', 
-                   [param('uint32_t', 'i')], 
+                   [param('uint16_t', 'i')], 
                    is_static=True)
-    ## type-id.h (module 'core'): static uint32_t ns3::TypeId::GetRegisteredN() [member function]
+    ## type-id.h (module 'core'): static uint16_t ns3::TypeId::GetRegisteredN() [member function]
     cls.add_method('GetRegisteredN', 
-                   'uint32_t', 
+                   'uint16_t', 
                    [], 
                    is_static=True)
     ## type-id.h (module 'core'): std::size_t ns3::TypeId::GetSize() const [member function]
@@ -2550,14 +2664,14 @@
                    'std::size_t', 
                    [], 
                    is_const=True)
-    ## type-id.h (module 'core'): ns3::TypeId::TraceSourceInformation ns3::TypeId::GetTraceSource(uint32_t i) const [member function]
+    ## type-id.h (module 'core'): ns3::TypeId::TraceSourceInformation ns3::TypeId::GetTraceSource(std::size_t i) const [member function]
     cls.add_method('GetTraceSource', 
                    'ns3::TypeId::TraceSourceInformation', 
-                   [param('uint32_t', 'i')], 
+                   [param('std::size_t', 'i')], 
                    is_const=True)
-    ## type-id.h (module 'core'): uint32_t ns3::TypeId::GetTraceSourceN() const [member function]
+    ## type-id.h (module 'core'): std::size_t ns3::TypeId::GetTraceSourceN() const [member function]
     cls.add_method('GetTraceSourceN', 
-                   'uint32_t', 
+                   'std::size_t', 
                    [], 
                    is_const=True)
     ## type-id.h (module 'core'): uint16_t ns3::TypeId::GetUid() const [member function]
@@ -2619,10 +2733,10 @@
                    'bool', 
                    [], 
                    is_const=True)
-    ## type-id.h (module 'core'): bool ns3::TypeId::SetAttributeInitialValue(uint32_t i, ns3::Ptr<const ns3::AttributeValue> initialValue) [member function]
+    ## type-id.h (module 'core'): bool ns3::TypeId::SetAttributeInitialValue(std::size_t i, ns3::Ptr<const ns3::AttributeValue> initialValue) [member function]
     cls.add_method('SetAttributeInitialValue', 
                    'bool', 
-                   [param('uint32_t', 'i'), param('ns3::Ptr< ns3::AttributeValue const >', 'initialValue')])
+                   [param('std::size_t', 'i'), param('ns3::Ptr< ns3::AttributeValue const >', 'initialValue')])
     ## type-id.h (module 'core'): ns3::TypeId ns3::TypeId::SetGroupName(std::string groupName) [member function]
     cls.add_method('SetGroupName', 
                    'ns3::TypeId', 
@@ -2828,6 +2942,11 @@
                    'uint32_t', 
                    [param('ns3::Buffer::Iterator', 'start')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## chunk.h (module 'network'): uint32_t ns3::Chunk::Deserialize(ns3::Buffer::Iterator start, ns3::Buffer::Iterator end) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start'), param('ns3::Buffer::Iterator', 'end')], 
+                   is_virtual=True)
     ## chunk.h (module 'network'): static ns3::TypeId ns3::Chunk::GetTypeId() [member function]
     cls.add_method('GetTypeId', 
                    'ns3::TypeId', 
@@ -3457,6 +3576,11 @@
                    'uint32_t', 
                    [param('ns3::Buffer::Iterator', 'end')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## trailer.h (module 'network'): uint32_t ns3::Trailer::Deserialize(ns3::Buffer::Iterator start, ns3::Buffer::Iterator end) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start'), param('ns3::Buffer::Iterator', 'end')], 
+                   is_virtual=True)
     ## trailer.h (module 'network'): uint32_t ns3::Trailer::GetSerializedSize() const [member function]
     cls.add_method('GetSerializedSize', 
                    'uint32_t', 
@@ -3977,10 +4101,10 @@
                    is_static=True)
     ## random-variable-stream.h (module 'core'): ns3::DeterministicRandomVariable::DeterministicRandomVariable() [constructor]
     cls.add_constructor([])
-    ## random-variable-stream.h (module 'core'): void ns3::DeterministicRandomVariable::SetValueArray(double * values, uint64_t length) [member function]
+    ## random-variable-stream.h (module 'core'): void ns3::DeterministicRandomVariable::SetValueArray(double * values, std::size_t length) [member function]
     cls.add_method('SetValueArray', 
                    'void', 
-                   [param('double *', 'values'), param('uint64_t', 'length')])
+                   [param('double *', 'values'), param('std::size_t', 'length')])
     ## random-variable-stream.h (module 'core'): double ns3::DeterministicRandomVariable::GetValue() [member function]
     cls.add_method('GetValue', 
                    'double', 
@@ -5136,6 +5260,11 @@
                    'uint32_t', 
                    [param('ns3::Header &', 'header')], 
                    is_const=True)
+    ## packet.h (module 'network'): uint32_t ns3::Packet::PeekHeader(ns3::Header & header, uint32_t size) const [member function]
+    cls.add_method('PeekHeader', 
+                   'uint32_t', 
+                   [param('ns3::Header &', 'header'), param('uint32_t', 'size')], 
+                   is_const=True)
     ## packet.h (module 'network'): bool ns3::Packet::PeekPacketTag(ns3::Tag & tag) const [member function]
     cls.add_method('PeekPacketTag', 
                    'bool', 
@@ -5180,6 +5309,10 @@
     cls.add_method('RemoveHeader', 
                    'uint32_t', 
                    [param('ns3::Header &', 'header')])
+    ## packet.h (module 'network'): uint32_t ns3::Packet::RemoveHeader(ns3::Header & header, uint32_t size) [member function]
+    cls.add_method('RemoveHeader', 
+                   'uint32_t', 
+                   [param('ns3::Header &', 'header'), param('uint32_t', 'size')])
     ## packet.h (module 'network'): bool ns3::Packet::RemovePacketTag(ns3::Tag & tag) [member function]
     cls.add_method('RemovePacketTag', 
                    'bool', 
@@ -5220,7 +5353,7 @@
     cls.add_method('GetMean', 
                    'double', 
                    [], 
-                   is_const=True)
+                   deprecated=True, is_const=True)
     ## random-variable-stream.h (module 'core'): double ns3::ParetoRandomVariable::GetScale() const [member function]
     cls.add_method('GetScale', 
                    'double', 
@@ -6006,15 +6139,15 @@
     cls.add_constructor([param('ns3::Hash::Implementation const &', 'arg0')])
     ## hash-function.h (module 'core'): ns3::Hash::Implementation::Implementation() [constructor]
     cls.add_constructor([])
-    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Implementation::GetHash32(char const * buffer, size_t const size) [member function]
+    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Implementation::GetHash32(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_pure_virtual=True, is_virtual=True)
-    ## hash-function.h (module 'core'): uint64_t ns3::Hash::Implementation::GetHash64(char const * buffer, size_t const size) [member function]
+    ## hash-function.h (module 'core'): uint64_t ns3::Hash::Implementation::GetHash64(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash64', 
                    'uint64_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_virtual=True)
     ## hash-function.h (module 'core'): void ns3::Hash::Implementation::clear() [member function]
     cls.add_method('clear', 
@@ -6050,10 +6183,10 @@
     cls.add_constructor([param('ns3::Hash::Function::Hash32 const &', 'arg0')])
     ## hash-function.h (module 'core'): ns3::Hash::Function::Hash32::Hash32(ns3::Hash::Hash32Function_ptr hp) [constructor]
     cls.add_constructor([param('ns3::Hash::Hash32Function_ptr', 'hp')])
-    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Function::Hash32::GetHash32(char const * buffer, size_t const size) [member function]
+    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Function::Hash32::GetHash32(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_virtual=True)
     ## hash-function.h (module 'core'): void ns3::Hash::Function::Hash32::clear() [member function]
     cls.add_method('clear', 
@@ -6067,15 +6200,15 @@
     cls.add_constructor([param('ns3::Hash::Function::Hash64 const &', 'arg0')])
     ## hash-function.h (module 'core'): ns3::Hash::Function::Hash64::Hash64(ns3::Hash::Hash64Function_ptr hp) [constructor]
     cls.add_constructor([param('ns3::Hash::Hash64Function_ptr', 'hp')])
-    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Function::Hash64::GetHash32(char const * buffer, size_t const size) [member function]
+    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Function::Hash64::GetHash32(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_virtual=True)
-    ## hash-function.h (module 'core'): uint64_t ns3::Hash::Function::Hash64::GetHash64(char const * buffer, size_t const size) [member function]
+    ## hash-function.h (module 'core'): uint64_t ns3::Hash::Function::Hash64::GetHash64(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash64', 
                    'uint64_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_virtual=True)
     ## hash-function.h (module 'core'): void ns3::Hash::Function::Hash64::clear() [member function]
     cls.add_method('clear', 
@@ -6089,15 +6222,15 @@
     cls.add_constructor([param('ns3::Hash::Function::Murmur3 const &', 'arg0')])
     ## hash-murmur3.h (module 'core'): ns3::Hash::Function::Murmur3::Murmur3() [constructor]
     cls.add_constructor([])
-    ## hash-murmur3.h (module 'core'): uint32_t ns3::Hash::Function::Murmur3::GetHash32(char const * buffer, size_t const size) [member function]
+    ## hash-murmur3.h (module 'core'): uint32_t ns3::Hash::Function::Murmur3::GetHash32(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash32', 
                    'uint32_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_virtual=True)
-    ## hash-murmur3.h (module 'core'): uint64_t ns3::Hash::Function::Murmur3::GetHash64(char const * buffer, size_t const size) [member function]
+    ## hash-murmur3.h (module 'core'): uint64_t ns3::Hash::Function::Murmur3::GetHash64(char const * buffer, std::size_t const size) [member function]
     cls.add_method('GetHash64', 
                    'uint64_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
+                   [param('char const *', 'buffer'), param('std::size_t const', 'size')], 
                    is_virtual=True)
     ## hash-murmur3.h (module 'core'): void ns3::Hash::Function::Murmur3::clear() [member function]
     cls.add_method('clear', 
@@ -6120,16 +6253,16 @@
     module.add_function('MakeWaypointChecker', 
                         'ns3::Ptr< ns3::AttributeChecker const >', 
                         [])
-    register_functions_ns3_FatalImpl(module.get_submodule('FatalImpl'), root_module)
-    register_functions_ns3_Hash(module.get_submodule('Hash'), root_module)
-    register_functions_ns3_TracedValueCallback(module.get_submodule('TracedValueCallback'), root_module)
+    register_functions_ns3_FatalImpl(module.add_cpp_namespace('FatalImpl'), root_module)
+    register_functions_ns3_Hash(module.add_cpp_namespace('Hash'), root_module)
+    register_functions_ns3_TracedValueCallback(module.add_cpp_namespace('TracedValueCallback'), root_module)
     return
 
 def register_functions_ns3_FatalImpl(module, root_module):
     return
 
 def register_functions_ns3_Hash(module, root_module):
-    register_functions_ns3_Hash_Function(module.get_submodule('Function'), root_module)
+    register_functions_ns3_Hash_Function(module.add_cpp_namespace('Function'), root_module)
     return
 
 def register_functions_ns3_Hash_Function(module, root_module):
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/mobility/examples/main-grid-topology.cc iab-psc/src/mobility/examples/main-grid-topology.cc
--- ns3-mmwave-iab/src/mobility/examples/main-grid-topology.cc	2019-02-15 18:12:55.479617762 +0100
+++ iab-psc/src/mobility/examples/main-grid-topology.cc	2019-02-15 18:13:15.907802139 +0100
@@ -34,7 +34,7 @@
   nodes.Create (120);
 
   MobilityHelper mobility;
-  // setup the grid itself: objects are layed out
+  // setup the grid itself: objects are laid out
   // started from (-100,-100) with 20 objects per row, 
   // the x interval between each object is 5 meters
   // and the y interval between each object is 20 meters
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/mobility/examples/ns2-mobility-trace.cc iab-psc/src/mobility/examples/ns2-mobility-trace.cc
--- ns3-mmwave-iab/src/mobility/examples/ns2-mobility-trace.cc	2019-02-15 18:12:55.479617762 +0100
+++ iab-psc/src/mobility/examples/ns2-mobility-trace.cc	2019-02-15 18:13:15.907802139 +0100
@@ -51,10 +51,8 @@
 #include <iostream>
 #include <fstream>
 #include <sstream>
-
 #include "ns3/core-module.h"
 #include "ns3/mobility-module.h"
-#include "ns3/mobility-module.h"
 #include "ns3/ns2-mobility-helper.h"
 
 using namespace ns3;
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/mobility/helper/group-mobility-helper.cc iab-psc/src/mobility/helper/group-mobility-helper.cc
--- ns3-mmwave-iab/src/mobility/helper/group-mobility-helper.cc	1970-01-01 01:00:00.000000000 +0100
+++ iab-psc/src/mobility/helper/group-mobility-helper.cc	2019-02-15 18:13:15.907802139 +0100
@@ -0,0 +1,115 @@
+/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2019 University of Padova
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Michele Polese <michele.polese@gmail.com>
+ */
+
+#include "ns3/group-mobility-helper.h"
+#include "ns3/mobility-model.h"
+#include "ns3/position-allocator.h"
+#include "ns3/group-slave-mobility-model.h"
+#include "ns3/log.h"
+#include "ns3/pointer.h"
+#include "ns3/config.h"
+#include "ns3/simulator.h"
+#include "ns3/names.h"
+#include "ns3/string.h"
+#include <iostream>
+
+namespace ns3 {
+
+NS_LOG_COMPONENT_DEFINE ("GroupMobilityHelper");
+
+GroupMobilityHelper::GroupMobilityHelper ()
+{
+  m_mobilityHelper = 0;
+}
+
+GroupMobilityHelper::~GroupMobilityHelper ()
+{
+  m_mobilityHelper = 0;
+}
+
+MobilityHelper*
+GroupMobilityHelper::GetMobilityHelper ()
+{
+  return m_mobilityHelper;
+}
+
+TypeId
+GroupMobilityHelper::GetTypeId (void)
+{
+  static TypeId
+    tid =
+    TypeId ("ns3::GroupMobilityHelper")
+    .SetParent<Object> ()
+    .AddConstructor<GroupMobilityHelper> ()
+    .AddAttribute ("GroupSlaveMobilityModel",
+                   "A string the specifies which slave mobility model should be used.",
+                   StringValue ("ns3::GroupSlaveMobilityModel"),
+                   MakeStringAccessor (&GroupMobilityHelper::m_slaveMobilityModel),
+                   MakeStringChecker ())
+    .AddAttribute ("PathDeviationRandomVariable",
+                   "A random variable used to pick the deviations (in each direction) from the master position.",
+                   StringValue ("ns3::NormalRandomVariable[Mean=0.0|Variance=1|Bound=20]"),
+                   MakeStringAccessor (&GroupMobilityHelper::m_randomVarString),
+                   MakeStringChecker ())
+  ;
+  return tid;
+}
+
+void
+GroupMobilityHelper::SetMobilityHelper (MobilityHelper* helper)
+{
+  m_mobilityHelper = helper;
+  m_privateMobilityHelper.SetMobilityModel (m_slaveMobilityModel,
+                                            "RandomVariable", StringValue (m_randomVarString));
+}
+
+NodeContainer
+GroupMobilityHelper::InstallGroupMobility (NodeContainer nodes)
+{
+  // check that the MobilityHelper is valid
+  NS_ABORT_MSG_IF (m_mobilityHelper == 0, "MobilityHelper not set");
+
+  // create the master node
+  Ptr<Node> referenceNode = CreateObject<Node>();
+  NodeContainer toBeReturned;
+  toBeReturned.Add (referenceNode);
+
+  // install the mobilitymodel in the referenceNode
+  (*m_mobilityHelper).Install (referenceNode);
+  Ptr<MobilityModel> referenceMobilityModel = referenceNode->GetObject<MobilityModel>();
+  Vector referencePosition = referenceMobilityModel->GetPosition ();
+
+  NS_LOG_INFO ("Reference starting position " << referencePosition);
+
+  // install the slave MobilityModel in the other nodes
+  for (auto nodeIt = nodes.Begin (); nodeIt != nodes.End (); ++nodeIt)
+    {
+      NS_LOG_INFO ("Install slave mobility in normal nodes");
+      m_privateMobilityHelper.Install ((*nodeIt));
+      (*nodeIt)->GetObject<GroupSlaveMobilityModel>()->SetMasterMobilityModel (referenceMobilityModel);
+      (*nodeIt)->GetObject<MobilityModel>()->SetPosition (referencePosition);
+    }
+
+  toBeReturned.Add (nodes);
+
+  return toBeReturned;
+}
+
+}
\ Manca newline alla fine del file
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/mobility/helper/group-mobility-helper.h iab-psc/src/mobility/helper/group-mobility-helper.h
--- ns3-mmwave-iab/src/mobility/helper/group-mobility-helper.h	1970-01-01 01:00:00.000000000 +0100
+++ iab-psc/src/mobility/helper/group-mobility-helper.h	2019-02-15 18:13:15.907802139 +0100
@@ -0,0 +1,87 @@
+/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2019 University of Padova
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Michele Polese <michele.polese@gmail.com>
+ */
+
+#ifndef GROUP_MOBILITY_HELPER_H
+#define GROUP_MOBILITY_HELPER_H
+
+#include <vector>
+#include "ns3/object-factory.h"
+#include "ns3/attribute.h"
+#include "ns3/output-stream-wrapper.h"
+#include "ns3/position-allocator.h"
+#include "node-container.h"
+#include "ns3/mobility-helper.h"
+
+namespace ns3 {
+
+class PositionAllocator;
+class MobilityModel;
+
+/**
+ * \ingroup mobility
+ * \brief Helper used to install master and slave mobility models
+ *
+ * GroupMobilityHelper::InstallGroupMobility is the most important method here.
+ */
+class GroupMobilityHelper : public Object
+{
+public:
+  /**
+   * Construct a GroupMobilityHelper
+   */
+  GroupMobilityHelper ();
+
+  /**
+   * Destroy a GroupMobilityHelper
+   */
+  ~GroupMobilityHelper ();
+
+  static TypeId GetTypeId (void);
+
+  /**
+   * Get a pointer to the associated MobilityHelper
+   * \return a pointer to the MobilityHelper
+   */
+  MobilityHelper* GetMobilityHelper();
+
+  /**
+   * Set a pointer to the associated MobilityHelper
+   * \param a pointer to the MobilityHelper
+   */
+  void SetMobilityHelper(MobilityHelper* helper);
+
+  /**
+   * Install the slave mobility model in the nodes passed as parameter
+   * \param nodes a NodeContainer with the slaves
+   * \return a NodeContainer with the master and the slaves
+   */
+  NodeContainer InstallGroupMobility(NodeContainer nodes);
+
+protected:
+  MobilityHelper* m_mobilityHelper; //!< the MobilityHelper used to configure the master
+  MobilityHelper m_privateMobilityHelper; //!< the MobilityHelper used to configure the slave
+  std::string m_randomVarString; //!< a string which describes the type of RandomVariableStream for the variance of the slaves
+  std::string m_slaveMobilityModel; //!< a string which describes the type of slave MobilityModel
+
+};
+
+} // namespace ns3
+
+#endif /* GROUP_MOBILITY_HELPER_H */
\ Manca newline alla fine del file
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/mobility/helper/ns2-mobility-helper.cc iab-psc/src/mobility/helper/ns2-mobility-helper.cc
--- ns3-mmwave-iab/src/mobility/helper/ns2-mobility-helper.cc	2019-02-15 18:12:55.479617762 +0100
+++ iab-psc/src/mobility/helper/ns2-mobility-helper.cc	2019-02-15 18:13:15.907802139 +0100
@@ -539,7 +539,7 @@
 
   while (ret.size () > 0 && isblank (ret[0]))
     {
-      ret.erase (0, 1);    // Removes blank spaces at the begining of the line
+      ret.erase (0, 1);    // Removes blank spaces at the beginning of the line
     }
 
   while (ret.size () > 0 && (isblank (ret[ret.size () - 1]) || (ret[ret.size () - 1] == ';')))
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/mobility/model/constant-acceleration-mobility-model.h iab-psc/src/mobility/model/constant-acceleration-mobility-model.h
--- ns3-mmwave-iab/src/mobility/model/constant-acceleration-mobility-model.h	2019-02-15 18:12:55.479617762 +0100
+++ iab-psc/src/mobility/model/constant-acceleration-mobility-model.h	2019-02-15 18:13:15.907802139 +0100
@@ -26,7 +26,7 @@
 /**
  * \ingroup mobility
  *
- * \brief Mobility model for which the current acceleration does not change once it has been set and until it is set again explicitely to a new value.
+ * \brief Mobility model for which the current acceleration does not change once it has been set and until it is set again explicitly to a new value.
  */
 class ConstantAccelerationMobilityModel : public MobilityModel 
 {
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/mobility/model/constant-position-mobility-model.h iab-psc/src/mobility/model/constant-position-mobility-model.h
--- ns3-mmwave-iab/src/mobility/model/constant-position-mobility-model.h	2019-02-15 18:12:55.479617762 +0100
+++ iab-psc/src/mobility/model/constant-position-mobility-model.h	2019-02-15 18:13:15.907802139 +0100
@@ -27,7 +27,7 @@
 /**
  * \ingroup mobility
  *
- * \brief Mobility model for which the current position does not change once it has been set and until it is set again explicitely to a new value.
+ * \brief Mobility model for which the current position does not change once it has been set and until it is set again explicitly to a new value.
  */
 class ConstantPositionMobilityModel : public MobilityModel 
 {
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/mobility/model/constant-velocity-mobility-model.h iab-psc/src/mobility/model/constant-velocity-mobility-model.h
--- ns3-mmwave-iab/src/mobility/model/constant-velocity-mobility-model.h	2019-02-15 18:12:55.479617762 +0100
+++ iab-psc/src/mobility/model/constant-velocity-mobility-model.h	2019-02-15 18:13:15.907802139 +0100
@@ -30,7 +30,7 @@
 /**
  * \ingroup mobility
  *
- * \brief Mobility model for which the current speed does not change once it has been set and until it is set again explicitely to a new value.
+ * \brief Mobility model for which the current speed does not change once it has been set and until it is set again explicitly to a new value.
  */
 class ConstantVelocityMobilityModel : public MobilityModel 
 {
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/mobility/model/group-slave-mobility-model.cc iab-psc/src/mobility/model/group-slave-mobility-model.cc
--- ns3-mmwave-iab/src/mobility/model/group-slave-mobility-model.cc	1970-01-01 01:00:00.000000000 +0100
+++ iab-psc/src/mobility/model/group-slave-mobility-model.cc	2019-02-15 18:13:15.907802139 +0100
@@ -0,0 +1,133 @@
+/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2019 University of Padova
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Michele Polese <michele.polese@gmail.com>
+ */
+#include "group-slave-mobility-model.h"
+#include "ns3/string.h"
+#include "ns3/uinteger.h"
+#include "ns3/pointer.h"
+#include "ns3/log.h"
+#include "ns3/node.h"
+#include "ns3/config.h"
+
+namespace ns3 {
+
+NS_OBJECT_ENSURE_REGISTERED (GroupSlaveMobilityModel);
+NS_LOG_COMPONENT_DEFINE ("GroupSlaveMobilityModel");
+
+TypeId
+GroupSlaveMobilityModel::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::GroupSlaveMobilityModel")
+    .SetParent<MobilityModel> ()
+    .SetGroupName ("Mobility")
+    .AddConstructor<GroupSlaveMobilityModel> ()
+    .AddAttribute ("RandomVariable",
+                   "A random variable used to pick the deviations (in each direction) from the master position.",
+                   StringValue ("ns3::NormalRandomVariable[Mean=0.0|Variance=1|Bound=20]"),
+                   MakePointerAccessor (&GroupSlaveMobilityModel::m_randomVar),
+                   MakePointerChecker<RandomVariableStream> ())
+    .AddAttribute ("MaxIterations",
+                   "Set a maximum number of iterations for the random sampling of the slave position, when checking for special conditions",
+                   UintegerValue(100000),
+                   MakeUintegerAccessor (&GroupSlaveMobilityModel::m_maxIterations),
+                   MakeUintegerChecker<uint32_t> ())
+  ;
+  return tid;
+}
+
+GroupSlaveMobilityModel::GroupSlaveMobilityModel ()
+{
+}
+GroupSlaveMobilityModel::~GroupSlaveMobilityModel ()
+{
+}
+
+
+void
+GroupSlaveMobilityModel::MasterCourseChanged (Ptr<MobilityModel const> master)
+{
+  NS_ABORT_MSG_IF (master != m_master, "cb master and private m_master are not the same");
+
+  Vector masterPosition = m_master->GetPosition ();
+  Vector position = DoGetPosition();
+
+  NS_LOG_INFO ("Master position " << masterPosition
+                                  << " randomizedPosition " << position);
+  NotifyCourseChange ();
+}
+
+void
+GroupSlaveMobilityModel::SetMasterMobilityModel (Ptr<MobilityModel> model)
+{
+  m_master = model;
+
+  // register the callback to MasterCourseChanged
+  auto nodeid = model->GetObject<Node>()->GetId ();
+  std::ostringstream oss;
+  oss << "/NodeList/" << nodeid << "/$ns3::MobilityModel/CourseChange";
+  Config::ConnectWithoutContext (oss.str (),
+                                 MakeCallback (&GroupSlaveMobilityModel::MasterCourseChanged, this));
+
+}
+
+bool
+GroupSlaveMobilityModel::CheckForSpecialConditions (Vector position) const
+{
+  // no special conditions to check here, simply a stub method
+  // that it easy to extend
+  return true;
+}
+
+
+Vector
+GroupSlaveMobilityModel::DoGetPosition (void) const
+{
+  // get the master position
+  Vector masterPosition = m_master->GetPosition ();
+  Vector position;
+  uint32_t iter = 0;
+  // get a new position and randomize until a valid position is found
+  do
+    {
+      ++iter;
+      position = Vector (
+          masterPosition.x + m_randomVar->GetValue (),
+          masterPosition.y + m_randomVar->GetValue (),
+          masterPosition.z
+          );
+    }
+  while (!CheckForSpecialConditions (position) && iter < m_maxIterations);
+
+  NS_ABORT_MSG_IF(iter > m_maxIterations, "Special condition not satisfied");
+  return position;
+}
+
+void
+GroupSlaveMobilityModel::DoSetPosition (const Vector &position)
+{
+  NotifyCourseChange ();
+}
+
+Vector
+GroupSlaveMobilityModel::DoGetVelocity (void) const
+{
+  return m_master->GetVelocity ();
+}
+
+} // namespace ns3
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/mobility/model/group-slave-mobility-model.h iab-psc/src/mobility/model/group-slave-mobility-model.h
--- ns3-mmwave-iab/src/mobility/model/group-slave-mobility-model.h	1970-01-01 01:00:00.000000000 +0100
+++ iab-psc/src/mobility/model/group-slave-mobility-model.h	2019-02-15 18:13:15.907802139 +0100
@@ -0,0 +1,92 @@
+/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2019 University of Padova
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Michele Polese <michele.polese@gmail.com>
+ */
+#ifndef GROUP_SLAVE_MOBILITY_MODEL_H
+#define GROUP_SLAVE_MOBILITY_MODEL_H
+
+#include "mobility-model.h"
+#include "ns3/random-variable-stream.h"
+
+namespace ns3 {
+
+/**
+ * \ingroup mobility
+ *
+ * \brief MobilityModel which follows a master MobilityModel with a certain deviation
+ */
+class GroupSlaveMobilityModel : public MobilityModel
+{
+public:
+  /**
+   * Register this type with the TypeId system.
+   * \return the object TypeId
+   */
+  static TypeId GetTypeId (void);
+
+  /**
+   * Create a GroupSlaveMobilityModel object
+   */
+  GroupSlaveMobilityModel ();
+  
+  /**
+   * Destroy a GroupSlaveMobilityModel object
+   */
+  virtual ~GroupSlaveMobilityModel ();
+
+  /**
+   * Get the associated master MobilityModel
+   * \return a smart pointer to the associated master MobilityModel
+   */
+  Ptr<MobilityModel> GetMasterMobilityModel ();
+
+  /**
+   * Set the associated master MobilityModel
+   * \param a smart pointer to the associated master MobilityModel
+   */
+  void SetMasterMobilityModel (Ptr<MobilityModel> model);
+
+  /**
+   * Method to be called when the master trigger the NotifyCourseChanged callback
+   * \param a smart pointer to the associated master MobilityModel
+   */
+  void MasterCourseChanged (Ptr<MobilityModel const> master);
+
+protected:
+  /**
+   * check for conditions that can lead to the rejection of the selected position
+   * \param postion a Vector with a position
+   * \return a bool, which is true if the special condition applies
+   */
+  virtual bool CheckForSpecialConditions (Vector position) const;
+
+private:
+  Vector DoGetPosition (void) const;
+  Vector DoGetVelocity (void) const;
+  void DoSetPosition (const Vector &position);
+
+protected:
+  Ptr<MobilityModel> m_master; //!< the master mobility model
+  Ptr<RandomVariableStream> m_randomVar; //<! the random variable that is used to randomize the position
+  Vector m_lastPosition; //!< the last position computed after a master course change
+  uint32_t m_maxIterations;
+};
+
+} // namespace ns3
+
+#endif /* GROUP_SLAVE_MOBILITY_MODEL_H */
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/mobility/model/hierarchical-mobility-model.cc iab-psc/src/mobility/model/hierarchical-mobility-model.cc
--- ns3-mmwave-iab/src/mobility/model/hierarchical-mobility-model.cc	2019-02-15 18:12:55.479617762 +0100
+++ iab-psc/src/mobility/model/hierarchical-mobility-model.cc	2019-02-15 18:13:15.907802139 +0100
@@ -129,7 +129,7 @@
     {
       return;
     }
-  // This implementation of DoSetPosition is really an arbitraty choice.
+  // This implementation of DoSetPosition is really an arbitrary choice.
   // anything else would have been ok.
   if (m_parent)
     {
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/mobility/model/position-allocator.cc iab-psc/src/mobility/model/position-allocator.cc
--- ns3-mmwave-iab/src/mobility/model/position-allocator.cc	2019-02-15 18:12:55.479617762 +0100
+++ iab-psc/src/mobility/model/position-allocator.cc	2019-02-15 18:13:15.907802139 +0100
@@ -102,7 +102,7 @@
     .SetParent<PositionAllocator> ()
     .SetGroupName ("Mobility")
     .AddConstructor<GridPositionAllocator> ()
-    .AddAttribute ("GridWidth", "The number of objects layed out on a line.",
+    .AddAttribute ("GridWidth", "The number of objects laid out on a line.",
                    UintegerValue (10),
                    MakeUintegerAccessor (&GridPositionAllocator::m_n),
                    MakeUintegerChecker<uint32_t> ())
@@ -114,6 +114,11 @@
                    DoubleValue (0.0),
                    MakeDoubleAccessor (&GridPositionAllocator::m_yMin),
                    MakeDoubleChecker<double> ())
+    .AddAttribute ("Z",
+                   "The z coordinate of all the positions allocated.",
+                   DoubleValue (0.0),
+                   MakeDoubleAccessor (&GridPositionAllocator::m_z),
+                   MakeDoubleChecker<double> ())
     .AddAttribute ("DeltaX", "The x space between objects.",
                    DoubleValue (1.0),
                    MakeDoubleAccessor (&GridPositionAllocator::m_deltaX),
@@ -146,6 +151,11 @@
   m_yMin = yMin;
 }
 void
+GridPositionAllocator::SetZ (double z)
+{
+  m_z = z;
+}
+void
 GridPositionAllocator::SetDeltaX (double deltaX)
 {
   m_deltaX = deltaX;
@@ -212,7 +222,7 @@
       break;
     }
   m_current++;
-  return Vector (x, y, 0.0);
+  return Vector (x, y, m_z);
 }
 
 int64_t
@@ -239,7 +249,13 @@
                    "A random variable which represents the y coordinate of a position in a random rectangle.",
                    StringValue ("ns3::UniformRandomVariable[Min=0.0|Max=1.0]"),
                    MakePointerAccessor (&RandomRectanglePositionAllocator::m_y),
-                   MakePointerChecker<RandomVariableStream> ());
+                   MakePointerChecker<RandomVariableStream> ())
+    .AddAttribute ("Z",
+                   "The z coordinate of all the positions allocated.",
+                   DoubleValue (0.0),
+                   MakeDoubleAccessor (&RandomRectanglePositionAllocator::m_z),
+                   MakeDoubleChecker<double> ())
+    ;
   return tid;
 }
 
@@ -260,13 +276,18 @@
 {
   m_y = y;
 }
+void
+RandomRectanglePositionAllocator::SetZ (double z)
+{
+  m_z = z;
+}
 
 Vector
 RandomRectanglePositionAllocator::GetNext (void) const
 {
   double x = m_x->GetValue ();
   double y = m_y->GetValue ();
-  return Vector (x, y, 0.0);
+  return Vector (x, y, m_z);
 }
 
 int64_t
@@ -374,6 +395,11 @@
                    DoubleValue (0.0),
                    MakeDoubleAccessor (&RandomDiscPositionAllocator::m_y),
                    MakeDoubleChecker<double> ())
+    .AddAttribute ("Z",
+                   "The z coordinate of all the positions in the disc.",
+                   DoubleValue (0.0),
+                   MakeDoubleAccessor (&RandomDiscPositionAllocator::m_z),
+                   MakeDoubleChecker<double> ())
   ;
   return tid;
 }
@@ -405,6 +431,11 @@
 {
   m_y = y;
 }
+void
+RandomDiscPositionAllocator::SetZ (double z)
+{
+  m_z = z;
+}
 Vector
 RandomDiscPositionAllocator::GetNext (void) const
 {
@@ -413,7 +444,7 @@
   double x = m_x + std::cos (theta) * rho;
   double y = m_y + std::sin (theta) * rho;
   NS_LOG_DEBUG ("Disc position x=" << x << ", y=" << y);
-  return Vector (x, y, 0.0);
+  return Vector (x, y, m_z);
 }
 
 int64_t
@@ -451,7 +482,7 @@
                    MakeDoubleAccessor (&UniformDiscPositionAllocator::m_y),
                    MakeDoubleChecker<double> ())
     .AddAttribute ("Z",
-                   "The height of each node.",
+                   "The z coordinate of all the positions in the disc.",
                    DoubleValue (0.0),
                    MakeDoubleAccessor (&UniformDiscPositionAllocator::m_z),
                    MakeDoubleChecker<double> ())
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/mobility/model/position-allocator.h iab-psc/src/mobility/model/position-allocator.h
--- ns3-mmwave-iab/src/mobility/model/position-allocator.h	2019-02-15 18:12:55.479617762 +0100
+++ iab-psc/src/mobility/model/position-allocator.h	2019-02-15 18:13:15.907802139 +0100
@@ -140,6 +140,10 @@
    */
   void SetMinY (double yMin);
   /**
+   * \param z   the Z coordinate of all the positions allocated 
+   */
+  void SetZ (double z);
+  /**
    * \param deltaX the x interval between two x-consecutive positions.
    */
   void SetDeltaX (double deltaX);
@@ -190,6 +194,7 @@
   enum LayoutType m_layoutType;  //!< currently selected layout type
   double m_xMin; //!< minimum boundary on x positions
   double m_yMin; //!< minimum boundary on y positions
+  double m_z; //!< z coordinate of all the positions generated
   uint32_t m_n;  //!< number of positions to allocate on each row or column
   double m_deltaX; //!< x interval between two consecutive x positions
   double m_deltaY; //!< y interval between two consecutive y positions
@@ -220,12 +225,17 @@
    * \param y pointer to a RandomVariableStream object
    */
   void SetY (Ptr<RandomVariableStream> y);
+  /** 
+   * \param z   the Z coordinate of all the positions allocated 
+   */
+  void SetZ (double z);
 
   virtual Vector GetNext (void) const;
   virtual int64_t AssignStreams (int64_t stream);
 private:
   Ptr<RandomVariableStream> m_x; //!< pointer to x's random variable stream
   Ptr<RandomVariableStream> m_y; //!< pointer to y's random variable stream
+  double m_z; //!< z coordinate of all the positions generated
 };
 
 /**
@@ -301,6 +311,10 @@
    * \param y   the Y coordinate of the center of the disc 
    */
   void SetY (double y);
+  /** 
+   * \param z   the Z coordinate of all the positions allocated 
+   */
+  void SetZ (double z);
 
   virtual Vector GetNext (void) const;
   virtual int64_t AssignStreams (int64_t stream);
@@ -309,6 +323,7 @@
   Ptr<RandomVariableStream> m_rho; //!< pointer to rho's random variable stream
   double m_x; //!< x coordinate of center of disc
   double m_y; //!< y coordinate of center of disc
+  double m_z;  //!< z coordinate of the disc
 };
 
 
@@ -317,7 +332,7 @@
  * \brief Allocate the positions uniformely (with constant density) randomly within a disc.
  *
  * UniformDiscPositionAllocator allocates the positions randomly within a disc \f$ D \f$ lying on the
- * plane \f$ z \f$ and having center at coordinates \f$ (x,y,z) \f$
+ * plane \f$ z\f$ and having center at coordinates \f$ (x,y,z) \f$
  * and radius \f$ \rho \f$. The random positions are chosen such that,
  * for any subset \f$ S \subset D \f$, the expected value of the
  * fraction of points which fall into \f$ S \subset D \f$ corresponds
@@ -356,7 +371,7 @@
   void SetY (double y);
 
   /** 
-   * \param z   the Z coordinate of all the elements in the disc
+   * \param z   the Z coordinate of all the positions allocated 
    */
   void SetZ (double z);
 
@@ -367,7 +382,7 @@
   double m_rho; //!< value of the radius of the disc
   double m_x;  //!< x coordinate of center of disc
   double m_y;  //!< y coordinate of center of disc
-  double m_z; //!< z coordinate that will be applied to all the elements in the disc
+  double m_z;  //!< z coordinate of the disc
 };
 
 } // namespace ns3
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/mobility/model/random-walk-2d-mobility-model.h iab-psc/src/mobility/model/random-walk-2d-mobility-model.h
--- ns3-mmwave-iab/src/mobility/model/random-walk-2d-mobility-model.h	2019-02-15 18:12:55.479617762 +0100
+++ iab-psc/src/mobility/model/random-walk-2d-mobility-model.h	2019-02-15 18:13:15.907802139 +0100
@@ -35,7 +35,7 @@
  * \ingroup mobility
  * \brief 2D random walk mobility model.
  *
- * Each instance moves with a speed and direction choosen at random
+ * Each instance moves with a speed and direction chosen at random
  * with the user-provided random variables until
  * either a fixed distance has been walked or until a fixed amount
  * of time. If we hit one of the boundaries (specified by a rectangle),
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/mobility/model/rectangle.cc iab-psc/src/mobility/model/rectangle.cc
--- ns3-mmwave-iab/src/mobility/model/rectangle.cc	2019-02-15 18:12:55.479617762 +0100
+++ iab-psc/src/mobility/model/rectangle.cc	2019-02-15 18:13:15.907802139 +0100
@@ -55,32 +55,120 @@
 Rectangle::Side
 Rectangle::GetClosestSide (const Vector &position) const
 {
-  double xMinDist = std::abs (position.x - this->xMin);
-  double xMaxDist = std::abs (this->xMax - position.x);
-  double yMinDist = std::abs (position.y - this->yMin);
-  double yMaxDist = std::abs (this->yMax - position.y);
-  double minX = std::min (xMinDist, xMaxDist);
-  double minY = std::min (yMinDist, yMaxDist);
-  if (minX < minY)
+  if (IsInside (position))
     {
-      if (xMinDist < xMaxDist)
+      double xMinDist = std::abs (position.x - this->xMin);
+      double xMaxDist = std::abs (this->xMax - position.x);
+      double yMinDist = std::abs (position.y - this->yMin);
+      double yMaxDist = std::abs (this->yMax - position.y);
+      double minX = std::min (xMinDist, xMaxDist);
+      double minY = std::min (yMinDist, yMaxDist);
+      if (minX < minY)
         {
-          return LEFT;
+          if (xMinDist < xMaxDist)
+            {
+              return LEFT;
+            }
+          else
+            {
+              return RIGHT;
+            }
         }
       else
         {
-          return RIGHT;
+          if (yMinDist < yMaxDist)
+            {
+              return BOTTOM;
+            }
+          else
+            {
+              return TOP;
+            }
         }
     }
   else
     {
-      if (yMinDist < yMaxDist)
+      if (position.x < this->xMin)
         {
-          return BOTTOM;
+          if (position.y < this->yMin)
+            {
+              double yDiff = this->yMin - position.y;
+              double xDiff = this->xMin - position.x;
+              if (yDiff > xDiff)
+                {
+                  return BOTTOM;
+                }
+              else
+                {
+                  return LEFT;
+                }
+            }
+          else if (position.y < this->yMax)
+            {
+              return LEFT;
+            }
+          else
+            {
+              double yDiff = position.y - this->yMax;
+              double xDiff = this->xMin - position.x;
+              if (yDiff > xDiff)
+                {
+                  return TOP;
+                }
+              else
+                {
+                  return LEFT;
+                }
+            }
+        }
+      else if (position.x < this->xMax)
+        {
+          if (position.y < this->yMin)
+            {
+              return BOTTOM;
+            }
+          else if (position.y < this->yMax)
+            {
+              NS_FATAL_ERROR ("This region should have been reached if the IsInside check was true");
+              return TOP; // silence compiler warning
+            }
+          else
+            {
+              return TOP;
+            }
         }
       else
         {
-          return TOP;
+          if (position.y < this->yMin)
+            {
+              double yDiff = this->yMin - position.y;
+              double xDiff = position.x - this->xMin;
+              if (yDiff > xDiff)
+                {
+                  return BOTTOM;
+                }
+              else
+                {
+                  return RIGHT;
+                }
+            }
+          else if (position.y < this->yMax)
+            {
+              return RIGHT;
+            }
+          else
+            {
+              double yDiff = position.y - this->yMax;
+              double xDiff = position.x - this->xMin;
+              if (yDiff > xDiff)
+                {
+                  return TOP;
+                }
+              else
+                {
+                  return RIGHT;
+                }
+            }
         }
     }
 }
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/mobility/model/steady-state-random-waypoint-mobility-model.cc iab-psc/src/mobility/model/steady-state-random-waypoint-mobility-model.cc
--- ns3-mmwave-iab/src/mobility/model/steady-state-random-waypoint-mobility-model.cc	2019-02-15 18:12:55.479617762 +0100
+++ iab-psc/src/mobility/model/steady-state-random-waypoint-mobility-model.cc	2019-02-15 18:13:15.907802139 +0100
@@ -95,6 +95,7 @@
   m_u_r = CreateObject<UniformRandomVariable> ();
   m_x = CreateObject<UniformRandomVariable> ();
   m_y = CreateObject<UniformRandomVariable> ();
+  m_position = CreateObject<RandomBoxPositionAllocator> ();
 }
 
 void
@@ -115,7 +116,6 @@
   m_speed->SetAttribute ("Max", DoubleValue (m_maxSpeed));
   NS_ASSERT (m_minX < m_maxX);
   NS_ASSERT (m_minY < m_maxY);
-  m_position = CreateObject<RandomBoxPositionAllocator> ();
   m_x->SetAttribute ("Min", DoubleValue (m_minX));
   m_x->SetAttribute ("Max", DoubleValue (m_maxX));
   m_y->SetAttribute ("Min", DoubleValue (m_minY));
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/mobility/test/steady-state-random-waypoint-mobility-model-test.cc iab-psc/src/mobility/test/steady-state-random-waypoint-mobility-model-test.cc
--- ns3-mmwave-iab/src/mobility/test/steady-state-random-waypoint-mobility-model-test.cc	2019-02-15 18:12:55.479617762 +0100
+++ iab-psc/src/mobility/test/steady-state-random-waypoint-mobility-model-test.cc	2019-02-15 18:13:15.907802139 +0100
@@ -82,7 +82,7 @@
     {
       // Create a new mobility model.
       Ptr<MobilityModel> model = mobilityFactory.Create ()->GetObject<MobilityModel> ();
-
+      model->AssignStreams (100 * (i + 1));
       // Add this mobility model to the stack.
       mobilityStack.push_back (model);
       Simulator::Schedule (Seconds (0.0), &Object::Initialize, model);
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/mobility/test/waypoint-mobility-model-test.cc iab-psc/src/mobility/test/waypoint-mobility-model-test.cc
--- ns3-mmwave-iab/src/mobility/test/waypoint-mobility-model-test.cc	2019-02-15 18:12:55.479617762 +0100
+++ iab-psc/src/mobility/test/waypoint-mobility-model-test.cc	2019-02-15 18:13:15.907802139 +0100
@@ -62,7 +62,7 @@
   /// Force updates
   void ForceUpdates (void);
   /**
-   * Course cange callback
+   * Course change callback
    * \param model the mobility model
    */
   void CourseChangeCallback (Ptr<const MobilityModel> model);
diff -Naru '--exclude=.git' ns3-mmwave-iab/src/mobility/wscript iab-psc/src/mobility/wscript
--- ns3-mmwave-iab/src/mobility/wscript	2019-02-15 18:12:55.479617762 +0100
+++ iab-psc/src/mobility/wscript	2019-02-15 18:13:15.907802139 +0100
@@ -22,6 +22,8 @@
         'model/waypoint-mobility-model.cc',
         'helper/mobility-helper.cc',
         'helper/ns2-mobility-helper.cc',
+        'helper/group-mobility-helper.cc',
+        'model/group-slave-mobility-model.cc'
         ]
 
     mobility_test = bld.create_ns3_module_test_library('mobility')
@@ -57,6 +59,8 @@
         'model/waypoint-mobility-model.h',
         'helper/mobility-helper.h',
         'helper/ns2-mobility-helper.h',
+        'helper/group-mobility-helper.h',
+        'model/group-slave-mobility-model.h'
         ]
 
     if (bld.env['ENABLE_EXAMPLES']):
